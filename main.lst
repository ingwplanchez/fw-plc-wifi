CCS PCM C Compiler, Version 4.104, 5967               05-oct.-19 06:34

               Filename: C:\Users\wplanchez\Desktop\Mecatronica Consultores\PROYECTOS\PLC Wifi\FW\main.lst

               ROM used: 4713 words (58%)
                         Largest free fragment is 2048
               RAM used: 77 (21%) at main() level
                         133 (36%) worst case
               Stack:    8 worst case (4 in main + 4 for interrupts)

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   3F3
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.4
0018:  GOTO   01B
0019:  BTFSC  0B.1
001A:  GOTO   032
001B:  MOVLW  8C
001C:  MOVWF  04
001D:  BTFSS  00.0
001E:  GOTO   021
001F:  BTFSC  0C.0
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BSF    0A.3
0033:  BCF    0A.4
0034:  GOTO   000
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   77E
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
*
01CA:  MOVLW  B9
01CB:  MOVWF  04
01CC:  BCF    03.7
01CD:  MOVF   00,W
01CE:  BTFSC  03.2
01CF:  GOTO   1DE
01D0:  MOVLW  01
01D1:  MOVWF  78
01D2:  CLRF   77
01D3:  DECFSZ 77,F
01D4:  GOTO   1D3
01D5:  DECFSZ 78,F
01D6:  GOTO   1D2
01D7:  MOVLW  4A
01D8:  MOVWF  77
01D9:  DECFSZ 77,F
01DA:  GOTO   1D9
01DB:  GOTO   1DC
01DC:  DECFSZ 00,F
01DD:  GOTO   1D0
01DE:  RETURN
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
0163:  MOVLW  0F
0164:  BSF    03.5
0165:  ANDWF  08,W
0166:  IORLW  F0
0167:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0168:  BCF    03.5
0169:  BSF    08.2
....................    delay_cycles(1); 
016A:  NOP
....................    lcd_output_enable(1); 
016B:  BSF    08.0
....................    delay_cycles(1); 
016C:  NOP
....................    high = lcd_read_nibble(); 
*
0172:  MOVF   78,W
0173:  BSF    03.5
0174:  MOVWF  40
....................        
....................    lcd_output_enable(0); 
0175:  BCF    03.5
0176:  BCF    08.0
....................    delay_cycles(1); 
0177:  NOP
....................    lcd_output_enable(1); 
0178:  BSF    08.0
....................    delay_us(1); 
0179:  NOP
....................    low = lcd_read_nibble(); 
*
017F:  MOVF   78,W
0180:  BSF    03.5
0181:  MOVWF  3F
....................        
....................    lcd_output_enable(0); 
0182:  BCF    03.5
0183:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0184:  MOVLW  0F
0185:  BSF    03.5
0186:  ANDWF  08,W
0187:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0188:  SWAPF  40,W
0189:  MOVWF  77
018A:  MOVLW  F0
018B:  ANDWF  77,F
018C:  MOVF   77,W
018D:  IORWF  3F,W
018E:  MOVWF  78
.................... } 
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
016D:  MOVF   08,W
016E:  MOVWF  77
016F:  SWAPF  08,W
0170:  ANDLW  0F
0171:  MOVWF  78
*
017A:  MOVF   08,W
017B:  MOVWF  77
017C:  SWAPF  08,W
017D:  ANDLW  0F
017E:  MOVWF  78
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
01AB:  SWAPF  40,W
01AC:  ANDLW  F0
01AD:  MOVWF  77
01AE:  MOVLW  0F
01AF:  BCF    03.5
01B0:  ANDWF  08,W
01B1:  IORWF  77,W
01B2:  MOVWF  08
*
01BD:  SWAPF  40,W
01BE:  ANDLW  F0
01BF:  MOVWF  77
01C0:  MOVLW  0F
01C1:  BCF    03.5
01C2:  ANDWF  08,W
01C3:  IORWF  77,W
01C4:  MOVWF  08
*
0920:  SWAPF  40,W
0921:  ANDLW  F0
0922:  MOVWF  77
0923:  MOVLW  0F
0924:  BCF    03.5
0925:  ANDWF  08,W
0926:  IORWF  77,W
0927:  MOVWF  08
*
093E:  SWAPF  40,W
093F:  ANDLW  F0
0940:  MOVWF  77
0941:  MOVLW  0F
0942:  BCF    03.5
0943:  ANDWF  08,W
0944:  IORWF  77,W
0945:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
*
01B3:  NOP
*
01C5:  NOP
*
0928:  NOP
*
0946:  NOP
....................    lcd_output_enable(1); 
*
01B4:  BSF    08.0
*
01C6:  BSF    08.0
*
0929:  BSF    08.0
*
0947:  BSF    08.0
....................    delay_us(2); 
*
01B5:  GOTO   1B6
*
01C7:  GOTO   1C8
*
092A:  GOTO   12B
*
0948:  GOTO   149
....................    lcd_output_enable(0); 
*
01B6:  BCF    08.0
*
01C8:  BCF    08.0
*
092B:  BCF    08.0
092C:  CLRF   27
092D:  BTFSC  0B.7
092E:  BSF    27.7
092F:  BCF    0B.7
*
0949:  BCF    08.0
.................... } 
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
....................    lcd_output_rs(0); 
*
0162:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
018F:  MOVF   78,W
0190:  MOVWF  3F
0191:  BTFSS  3F.7
0192:  GOTO   195
0193:  BCF    03.5
0194:  GOTO   163
....................    lcd_output_rs(address); 
0195:  BTFSC  3D.0
0196:  GOTO   19A
0197:  BCF    03.5
0198:  BCF    08.1
0199:  BSF    03.5
019A:  BTFSS  3D.0
019B:  GOTO   19F
019C:  BCF    03.5
019D:  BSF    08.1
019E:  BSF    03.5
....................    delay_cycles(1); 
019F:  NOP
....................    lcd_output_rw(0); 
01A0:  BCF    03.5
01A1:  BCF    08.2
....................    delay_cycles(1); 
01A2:  NOP
....................    lcd_output_enable(0); 
01A3:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
01A4:  BSF    03.5
01A5:  SWAPF  3E,W
01A6:  MOVWF  3F
01A7:  MOVLW  0F
01A8:  ANDWF  3F,F
01A9:  MOVF   3F,W
01AA:  MOVWF  40
....................    lcd_send_nibble(n & 0xf); 
*
01B7:  BSF    03.5
01B8:  MOVF   3E,W
01B9:  ANDLW  0F
01BA:  MOVWF  3F
01BB:  MOVF   3F,W
01BC:  MOVWF  40
.................... } 
*
01C9:  RETURN
....................  
.................... void lcd_init(void)  
.................... { 
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
*
08FF:  MOVLW  0F
0900:  BSF    03.5
0901:  ANDWF  08,W
0902:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
0903:  BCF    08.0
....................    lcd_rs_tris(); 
0904:  BCF    08.1
....................    lcd_rw_tris(); 
0905:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0906:  BCF    03.5
0907:  BCF    08.1
....................    lcd_output_rw(0); 
0908:  BCF    08.2
....................    lcd_output_enable(0); 
0909:  BCF    08.0
090A:  CLRF   27
090B:  BTFSC  0B.7
090C:  BSF    27.7
090D:  BCF    0B.7
....................      
....................    delay_ms(15); 
090E:  MOVLW  0F
090F:  BSF    03.5
0910:  MOVWF  39
0911:  BCF    0A.3
0912:  BCF    03.5
0913:  CALL   1CA
0914:  BSF    0A.3
0915:  BTFSC  27.7
0916:  BSF    0B.7
....................    for(i=1;i<=3;++i) 
0917:  MOVLW  01
0918:  MOVWF  67
0919:  MOVF   67,W
091A:  SUBLW  03
091B:  BTFSS  03.0
091C:  GOTO   13B
....................    { 
....................        lcd_send_nibble(3); 
091D:  MOVLW  03
091E:  BSF    03.5
091F:  MOVWF  40
....................        delay_ms(5); 
*
0930:  MOVLW  05
0931:  BSF    03.5
0932:  MOVWF  39
0933:  BCF    0A.3
0934:  BCF    03.5
0935:  CALL   1CA
0936:  BSF    0A.3
0937:  BTFSC  27.7
0938:  BSF    0B.7
....................    } 
0939:  INCF   67,F
093A:  GOTO   119
....................      
....................    lcd_send_nibble(2); 
093B:  MOVLW  02
093C:  BSF    03.5
093D:  MOVWF  40
....................    for(i=0;i<=3;++i) 
*
094A:  CLRF   67
094B:  MOVF   67,W
094C:  SUBLW  03
094D:  BTFSS  03.0
094E:  GOTO   166
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
094F:  MOVF   67,W
0950:  BCF    0A.3
0951:  CALL   038
0952:  BSF    0A.3
0953:  MOVWF  68
0954:  CLRF   27
0955:  BTFSC  0B.7
0956:  BSF    27.7
0957:  BCF    0B.7
0958:  BSF    03.5
0959:  CLRF   3D
095A:  BCF    03.5
095B:  MOVF   68,W
095C:  BSF    03.5
095D:  MOVWF  3E
095E:  BCF    0A.3
095F:  BCF    03.5
0960:  CALL   162
0961:  BSF    0A.3
0962:  BTFSC  27.7
0963:  BSF    0B.7
0964:  INCF   67,F
0965:  GOTO   14B
.................... } 
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
01FD:  DECFSZ 3A,W
01FE:  GOTO   200
01FF:  GOTO   203
....................       address=LCD_LINE_TWO; 
0200:  MOVLW  40
0201:  MOVWF  3B
....................    else 
0202:  GOTO   204
....................       address=0; 
0203:  CLRF   3B
....................       
....................    address+=x-1; 
0204:  MOVLW  01
0205:  SUBWF  39,W
0206:  ADDWF  3B,F
....................    lcd_send_byte(0,0x80|address); 
0207:  MOVF   3B,W
0208:  IORLW  80
0209:  MOVWF  3C
020A:  CLRF   3D
020B:  MOVF   3C,W
020C:  MOVWF  3E
020D:  BCF    03.5
020E:  CALL   162
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
*
01DF:  BSF    03.5
01E0:  MOVF   38,W
01E1:  XORLW  0C
01E2:  BCF    03.5
01E3:  BTFSC  03.2
01E4:  GOTO   1EC
01E5:  XORLW  06
01E6:  BTFSC  03.2
01E7:  GOTO   1F8
01E8:  XORLW  02
01E9:  BTFSC  03.2
01EA:  GOTO   210
01EB:  GOTO   217
....................       case '\f'   :  lcd_send_byte(0,1); 
01EC:  BSF    03.5
01ED:  CLRF   3D
01EE:  MOVLW  01
01EF:  MOVWF  3E
01F0:  BCF    03.5
01F1:  CALL   162
....................                      delay_ms(2); 
01F2:  MOVLW  02
01F3:  BSF    03.5
01F4:  MOVWF  39
01F5:  BCF    03.5
01F6:  CALL   1CA
....................                      break; 
01F7:  GOTO   21F
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01F8:  MOVLW  01
01F9:  BSF    03.5
01FA:  MOVWF  39
01FB:  MOVLW  02
01FC:  MOVWF  3A
*
020F:  GOTO   21F
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0210:  BSF    03.5
0211:  CLRF   3D
0212:  MOVLW  10
0213:  MOVWF  3E
0214:  BCF    03.5
0215:  CALL   162
0216:  GOTO   21F
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0217:  MOVLW  01
0218:  BSF    03.5
0219:  MOVWF  3D
021A:  MOVF   38,W
021B:  MOVWF  3E
021C:  BCF    03.5
021D:  CALL   162
021E:  GOTO   21F
....................    } 
.................... } 
021F:  RETURN
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
....................    #include <mensajes.h> 
.................... #ifndef __MENSAJES_H_ 
.................... #define __MENSAJES_H_ 
....................  
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
....................    #include <mensajes.h> 
....................    #include <mensajes.c> 
....................     
....................    #include <drv_lcd.h> 
....................    #include <drv_lcd.c> 
....................    #include <drv_gpio.h> 
....................    #include <drv_gpio.c>  
....................    #include <drv_esp8266.h> 
....................    #include <drv_esp8266.c> 
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
....................  
....................    #define MODO               "MODO\n"  
....................    #define MODO_              "MODO<\n"  
....................       #define LAVADO          "LAVADO\n" 
....................       #define LAVADO_         "LAVADO<\n" 
....................       #define CENTRIFUGADO    "CENTRIFUGADO\n" 
....................       #define CENTRIFUGADO_   "CENTRIFUGADO<\n" 
....................       #define AUTOM            "AUTOMATICO\n" 
....................       #define AUTOM_           "AUTOMATICO<\n" 
....................        
....................    #define TEMPERATURA        "TEMPERATURA\n"  
....................    #define TEMPERATURA_       "TEMPERATURA<\n"  
....................       #define FRIA            "FRIA\n" 
....................       #define FRIA_           "FRIA<\n" 
....................       #define CALIENTE         "CALIENTE\n" 
....................       #define CALIENTE_       "CALIENTE<\n" 
....................       #define TEMP_AMBOS      "FRIA/CALIENTE\n" 
....................       #define TEMP_AMBOS_     "FRIA/CALIENTE<\n"   
....................        
....................    #define NIVEL              "NIVEL\n"  
....................    #define NIVEL_             "NIVEL<\n" 
....................       #define MUY_BAJO        "MUY BAJO\n" 
....................       #define MUY_BAJO_       "MUY BAJO<\n" 
....................       #define BAJO            "BAJO\n" 
....................       #define BAJO_           "BAJO<\n" 
....................       #define MEDIO           "MEDIO\n" 
....................       #define MEDIO_          "MEDIO<\n" 
....................       #define ALTO            "ALTO\n" 
....................       #define ALTO_           "ALTO<\n" 
....................       #define TIEMPO             "TIEMPO\n"  
....................        
....................    #define TIEMPO_            "TIEMPO<\n"  
....................       #define T_25MIN         "25 MIN\n" 
....................       #define T_25MIN_        "25 MIN<\n" 
....................       #define T_35MIN         "35 MIN\n" 
....................       #define T_35MIN_        "35 MIN<\n" 
....................       #define T_45MIN         "45 MIN\n" 
....................       #define T_45MIN_        "45 MIN<\n" 
....................       #define T_55MIN         "55 MIN\n" 
....................       #define T_55MIN_        "55 MIN<\n" 
....................       #define T_SELECCION     "\fTIEMPO:%2dm\n" 
....................    
....................    #define ATRAS              "ATRAS<\n"   
....................    #define EMPRESA            "EMPRESA\n"  
....................    #define EMPRESA_           "EMPRESA<\n"  
....................     
....................     
....................     
.................... //char const * Mensaje_leer(MensajeID mensajeID); 
....................  
.................... #endif 
....................  
....................    #include <mensajes.c> 
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
....................    #include <mensajes.h> 
....................    #include <mensajes.c> 
....................     
....................    #include <drv_lcd.h> 
....................    #include <drv_lcd.c> 
....................    #include <drv_gpio.h> 
....................    #include <drv_gpio.c>  
....................    #include <drv_esp8266.h> 
....................    #include <drv_esp8266.c> 
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
.................... #include "string.h" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0C0C:  BCF    03.5
0C0D:  CLRF   28
0C0E:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................     
....................    #include <drv_lcd.h> 
.................... #ifndef __DRV_LCD_H 
.................... #define __DRV_LCD_H 
....................  
....................    void drv_lcd_show(); 
....................    //void drv_lcd_mensaje(MensajeID mensajeID); 
....................    //void drv_lcd_mensaje2(MensajeID mensajeID1,MensajeID mensajeID2); 
....................    void drv_lcd_show1(char * cmd); 
....................    //void drv_gpio_lcd_menu(); 
....................     
....................     
.................... #endif /* __DRV_LCD_H */ 
....................  
....................  
....................    #include <drv_lcd.c> 
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
....................    #include <mensajes.h> 
....................    #include <mensajes.c> 
....................     
....................    #include <drv_lcd.h> 
....................    #include <drv_lcd.c> 
....................    #include <drv_gpio.h> 
....................    #include <drv_gpio.c>  
....................    #include <drv_esp8266.h> 
....................    #include <drv_esp8266.c> 
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
....................  
.................... //int me = 0; 
.................... void drv_lcd_show(){ 
....................       printf(lcd_putc,"\f<<EVOLUTRONICA>>\n"); 
*
07D8:  MOVLW  40
07D9:  BSF    03.6
07DA:  MOVWF  0D
07DB:  MOVLW  00
07DC:  MOVWF  0F
07DD:  BCF    03.6
07DE:  CALL   782
....................       printf(lcd_putc,"   (PLC WIFI)"); 
07DF:  MOVLW  4A
07E0:  BSF    03.6
07E1:  MOVWF  0D
07E2:  MOVLW  00
07E3:  MOVWF  0F
07E4:  BCF    03.6
07E5:  CALL   782
....................       delay_ms(1000); 
07E6:  MOVLW  04
07E7:  MOVWF  67
07E8:  CLRF   27
07E9:  BTFSC  0B.7
07EA:  BSF    27.7
07EB:  BCF    0B.7
07EC:  MOVLW  FA
07ED:  BSF    03.5
07EE:  MOVWF  39
07EF:  BCF    03.5
07F0:  CALL   1CA
07F1:  BTFSC  27.7
07F2:  BSF    0B.7
07F3:  DECFSZ 67,F
07F4:  GOTO   7E8
....................       
.................... } 
07F5:  BSF    0A.3
07F6:  BCF    0A.4
07F7:  GOTO   417 (RETURN)
....................  
.................... void drv_lcd_show1(char * cmd){ 
....................       printf(lcd_putc,"\f"); 
....................       printf(lcd_putc,(char *)cmd); 
....................       printf(lcd_putc,"\n"); 
....................  
.................... } 
....................  
....................  
....................  
....................  
....................    #include <drv_gpio.h> 
.................... #ifndef __DRV_GPIO_H 
.................... #define __DRV_GPIO_H 
....................  
....................    //PINES PUERTO A 
....................    #define NIVEL_COMBUSTIBLE        pin_a0 
....................    #define V_ALTERMADOR             pin_a1 
....................    #define V_GENERADOR_F1           pin_a2 
....................    #define V_GENERADOR_F2           pin_a3 
....................    #define V_CALLE_F1               pin_a5 
....................     
....................    //PINES PUERTO E 
....................    // #define V_CALLE_F2            pin_e0 
....................    //#define BOTON_SELECT           pin_e1 
....................    
....................    //PINES PUERTO B 
....................    // #define                       pin_b0 
....................    #define TEMP_ALARMA              pin_b1 
....................    #define PRESION_ALARMA           pin_b2 
....................    #define A_MANUAL                 pin_b3 
....................    #define A_AUTOMATICO             pin_b4 
....................    #define F_AUTOMATICO             pin_b5 
....................    #define P_EMERGENCIA             pin_b6   
....................    #define STOP_RESET               pin_b7  
....................  
....................    //PINES PUERTO C 
....................    #define ARRANQUE_ENCENDIDO       pin_c0 
....................    #define SOLENOIDE                pin_c1 
....................    #define E_ALTERNADOR             pin_c2 
....................    #define BUZZER                   pin_c3 
....................    #define TRANSFER                 pin_c4 
....................    #define BOTON_MOSTRAR            pin_c5 
....................    #define SOLENOIDE3               pin_c6 
....................    #define SOLENOIDE4               pin_c7 
....................     
....................    #define SIN_MODO                 0x00 
....................    #define MODO_INICIO              0x01 
....................    #define MODO_ARRANQUE            0x02 
....................    #define MODO_ARRANQUE_A          0x03 
....................    #define MODO_ARRANQUE_M          0x04   
....................     
....................  
....................    // FUNCIONES D USO GNERAL 
....................     
....................    //void drv_gpio_int_rb(); 
....................    //void drv_gpio_int_rb0(); 
....................  
....................    void drv_gpio_seg(int segundos); 
....................    /* 
....................    void drv_gpio_finish0(); 
....................    void drv_gpio_finish1(); 
....................    void drv_gpio_off(); 
....................    //void drv_gpio_clear(); 
.................... */ 
....................     
....................    //GPIO ADC 
....................     
....................    int16 drv_gpio_adc_read(int channel); 
....................     
....................    void drv_gpio_adc_lcd(); 
....................    void drv_gpio_adc_show(int channel); 
....................    void drv_gpio_adc_select(); 
....................     
....................    void drv_rpm_int_rb(void); 
....................    void drv_rpm_int_ext(void); 
....................    void drv_rpm_show(void); 
....................    void drv_rpm_capture(void); 
....................    int1 drv_gpio_alarmas(void); 
....................    void drv_gpio_modo(void); 
....................    void drv_gpio_arranque(void);   
....................    
....................    void drv_gpio_control_time(); 
....................     
....................    void drv_gpio_lcd_show1(char * cmd); 
....................    void drv_gpio_lcd_show2(char * cmd,char * cmd1);    
....................    void drv_gpio_pulsadores(); 
....................     
....................    void drv_gpio_arranque_P_on(void); // Arranque Planta 
....................    void drv_gpio_arranque_P_off(void); 
....................    void drv_gpio_arranque_A_on(void); //Exitacion alternador 
....................    void drv_gpio_arranque_A_off(void); 
....................    void drv_gpio_solenoide_on(void); //Exitacion alternador 
....................    void drv_gpio_solenoide_off(void); 
....................    void drv_gpio_transfer_on(void); //Activar transfer alternador 
....................    void drv_gpio_transfer_off(void); 
....................    void drv_activar_transfer(void); 
....................    void drv_gpio_generador_activo(void); 
....................     
....................     
....................  
.................... #endif /* __DRV_LCD_H */ 
....................  
....................  
....................  
....................    #include <drv_gpio.c>  
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
....................    #include <mensajes.h> 
....................    #include <mensajes.c> 
....................     
....................    #include <drv_lcd.h> 
....................    #include <drv_lcd.c> 
....................    #include <drv_gpio.h> 
....................    #include <drv_gpio.c>  
....................    #include <drv_esp8266.h> 
....................    #include <drv_esp8266.c> 
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
.................... //#include <drv_rpm.h> 
....................  
.................... #define AntiRebote1(PIN)    do{if(input(PIN)==1){break;}}while(1) 
.................... #define AntiRebote0(PIN)    do{if(input(PIN)==0){break;}}while(1) 
....................  
.................... int1 Flag_ejecutar,Flag_salir; 
.................... int1 Flag_sub_menu1,Flag_Show,Flag_Alarmas, Flag_Arranque,Flag_MostrarADC; 
....................  
.................... int Status, Status_modo; 
.................... int time,segundos,minutos,seg,min; 
.................... int Select = 0; 
.................... int16 transfer_on = 0; 
.................... int16 Vtemperatura,Vnivel,Vch1,Vch2; 
.................... int1 Flag_Automatico = 0; 
.................... int1 Flag_Manual = 0; 
.................... //////////////////////////////////////////////// 
.................... int1 Completado;     // Cuenta del periodo completada 
.................... int1 Flanco;         // Variable para la deteccion del flanco: 
....................                      // Flanco = 0 (Espera Flanco de subida) 
....................                      // Flanco = 1 (Espera Flanco de bajada) 
.................... int Numero_Flanco;   // Indica el numero de flanco 
....................  
.................... int16 T1,T2,T3,F,DUTY_Actual;    // Variables para guardar  
....................                                        //los valores del Timer 
.................... int16 T_High,T_Low,T_Total;            // Variables para guardar: 
....................                               // T_Higth ->  Semiperiodo Alto 
....................                               // T_Low -> Semiperiodo Bajo 
....................                               // T_Total -> Priodo total 
.................... Float P,P_ms,Ta,Vout;         // P -> Periodo 
....................                               // F -> Frecuencia 
....................  
.................... int32 rpm,rpm_Old; 
.................... /////////////////////////////////////////////// 
....................  
.................... void drv_gpio_adc_select(){ 
....................     
....................    if (input(BOTON_MOSTRAR)==0){  
*
0BE3:  BTFSC  07.5
0BE4:  GOTO   3F0
....................       //delay_ms(250); 
....................       AntiRebote1(BOTON_MOSTRAR); 
0BE5:  BTFSS  07.5
0BE6:  GOTO   3E8
0BE7:  GOTO   3E9
....................       Select++; 
0BE8:  GOTO   3E5
0BE9:  INCF   32,F
....................       if(Select>4){Select=0;Flag_Show = 0;} 
0BEA:  MOVF   32,W
0BEB:  SUBLW  04
0BEC:  BTFSC  03.0
0BED:  GOTO   3F0
0BEE:  CLRF   32
0BEF:  BCF    2A.3
....................    }    
.................... } 
0BF0:  BSF    0A.3
0BF1:  BCF    0A.4
0BF2:  GOTO   46F (RETURN)
....................  
....................  
.................... void drv_gpio_int_rb(){} 
....................  
.................... void drv_gpio_clear(){} 
....................  
.................... void drv_gpio_finish1(){ 
....................    Flag_ejecutar = 0; 
....................    Flag_sub_menu1 = 1; 
....................    //Status_nivel = 1;    
.................... } 
....................  
.................... void drv_gpio_finish0(){ 
....................    Flag_ejecutar = 0; 
....................    Flag_sub_menu1 = 0; 
....................    //Status_nivel = 0;    
.................... } 
....................  
.................... void drv_gpio_off(){ 
....................    output_c(0b00000000);  
....................    output_e(0b00000000);   
....................    set_pwm1_duty(5); 
.................... } 
....................  
.................... void drv_gpio_control_time(){ 
....................     
....................    seg++; 
....................    if(seg>59){ 
....................       min++; 
....................       seg = 0; 
....................    } 
....................     
....................    lcd_gotoxy(1,2); 
....................     
....................    if(seg<10){ 
....................       printf(lcd_putc,"Tiempo:%2dm:0%ds\n",min,seg); 
....................    } 
....................    else{ 
....................       printf(lcd_putc,"Tiempo:%2dm:%2ds\n",min,seg); 
....................    } 
....................     
.................... } 
....................  
.................... void drv_gpio_seg(int segundos){ 
....................  
.................... int i,j; 
....................  
....................    for(i = 1; i <=segundos; i++){ 
....................        
....................       for(j = 0; j <=10; j++){ 
....................          delay_ms(100); 
....................     
....................       } 
....................    }   
....................        
....................    i = 0; 
....................  
.................... } 
....................  
....................  
.................... void drv_gpio_pulsadores(){} 
....................  
.................... //GPIO ADC 
....................  
.................... int16 drv_gpio_adc_read(int channel){ 
*
0B82:  CLRF   6A
0B83:  CLRF   69
0B84:  BCF    6B.0
....................  
....................    int16 medicion=0;                     //variable entera que contendra la medicion del convertidor AD 
....................    int1 done = 0;                        //Contendra 1 si el convertidor termin de convertir 
....................    //AN0_AN1_AN2_AN3_AN4_AN5  
....................    //setup_adc_ports(AN0_AN1_AN2_AN3_AN4_AN5); // CANALES ANALOGICOS A0 A1 A2 A3 A5 E0  
....................    setup_adc_ports(ALL_ANALOG); 
0B85:  BSF    03.5
0B86:  BCF    1F.0
0B87:  BCF    1F.1
0B88:  BCF    1F.2
0B89:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); // conversion analogica con el reloj interno 
0B8A:  BCF    1F.6
0B8B:  BCF    03.5
0B8C:  BSF    1F.6
0B8D:  BSF    1F.7
0B8E:  BSF    03.5
0B8F:  BSF    1F.7
0B90:  BCF    03.5
0B91:  BSF    1F.0
....................    set_adc_channel (channel);          //Establecemos el canal de lectura analogica 
0B92:  RLF    68,W
0B93:  MOVWF  77
0B94:  RLF    77,F
0B95:  RLF    77,F
0B96:  MOVLW  F8
0B97:  ANDWF  77,F
0B98:  MOVF   1F,W
0B99:  ANDLW  C7
0B9A:  IORWF  77,W
0B9B:  MOVWF  1F
0B9C:  CLRF   27
0B9D:  BTFSC  0B.7
0B9E:  BSF    27.7
0B9F:  BCF    0B.7
....................    delay_ms(1);                       //a small delay is required after setting the channel 
0BA0:  MOVLW  01
0BA1:  BSF    03.5
0BA2:  MOVWF  39
0BA3:  BCF    0A.3
0BA4:  BCF    03.5
0BA5:  CALL   1CA
0BA6:  BSF    0A.3
0BA7:  BTFSC  27.7
0BA8:  BSF    0B.7
....................    medicion=read_adc ();               // Hace conversin AD  
0BA9:  BSF    1F.2
0BAA:  BTFSC  1F.2
0BAB:  GOTO   3AA
0BAC:  BSF    03.5
0BAD:  MOVF   1E,W
0BAE:  BCF    03.5
0BAF:  MOVWF  69
0BB0:  MOVF   1E,W
0BB1:  MOVWF  6A
....................    done = adc_done();                  //done = 1 si el convertidor termino de convertir 
0BB2:  BCF    6B.0
0BB3:  BTFSS  1F.2
0BB4:  BSF    6B.0
....................    while(!done) 
....................    { 
0BB5:  BTFSC  6B.0
0BB6:  GOTO   3BB
....................       done = adc_done();               //Mientras no acabe de convertir se seguira ciclando 
0BB7:  BCF    6B.0
0BB8:  BTFSS  1F.2
0BB9:  BSF    6B.0
....................    } 
0BBA:  GOTO   3B5
....................    setup_adc (adc_off);                //detenemos al convertidor 
0BBB:  BCF    1F.0
....................    //medicion = (medicion/1023.0)*5; 
....................    return medicion;    
0BBC:  MOVF   69,W
0BBD:  MOVWF  78
0BBE:  MOVF   6A,W
0BBF:  MOVWF  79
.................... } 
0BC0:  RETURN
....................  
.................... void drv_gpio_adc_lcd(){ 
*
0072:  DATA 00,00
....................  
....................    Vtemperatura = drv_gpio_adc_read(0); 
....................    Vnivel = drv_gpio_adc_read(1); 
....................    printf(lcd_putc,"\fTEMP : %2.1fv\n",(Vtemperatura/1023.0)*5); 
....................    printf(lcd_putc,"NIVEL: %2.1fv\n",(Vnivel/1023.0)*5); 
....................    delay_ms(100); 
....................  
.................... } 
....................  
.................... void drv_gpio_adc_show(int channel){ 
....................  
....................    switch(channel){ 
*
1000:  MOVF   67,W
1001:  ADDLW  FA
1002:  BTFSC  03.0
1003:  GOTO   5EB
1004:  ADDLW  06
1005:  GOTO   5EE
....................       case 0: 
....................       Flag_Show = 0; 
1006:  BCF    2A.3
....................        drv_rpm_int_ext(); 
....................       drv_rpm_capture(); 
*
10DA:  BCF    0A.4
10DB:  CALL   609
10DC:  BSF    0A.4
10DD:  BTFSC  27.7
10DE:  BSF    0B.7
....................       //delay_ms(100); 
....................       break; 
10DF:  GOTO   5EB
....................     case 1: 
....................       Flag_Show = 0; 
10E0:  BCF    2A.3
....................       Vch1 = drv_gpio_adc_read(0); 
10E1:  CLRF   68
10E2:  BCF    0A.4
10E3:  BSF    0A.3
10E4:  CALL   382
10E5:  BSF    0A.4
10E6:  BCF    0A.3
10E7:  MOVF   79,W
10E8:  MOVWF  3A
10E9:  MOVF   78,W
10EA:  MOVWF  39
10EB:  CLRF   27
10EC:  BTFSC  0B.7
10ED:  BSF    27.7
10EE:  BCF    0B.7
....................       printf(lcd_putc,"\fCOMBUST.: %2.1fv\n",(Vch1/1023.0)*5);    
10EF:  MOVF   3A,W
10F0:  BSF    03.5
10F1:  MOVWF  2C
10F2:  BCF    03.5
10F3:  MOVF   39,W
10F4:  BSF    03.5
10F5:  MOVWF  2B
10F6:  BCF    0A.4
10F7:  BCF    03.5
10F8:  CALL   51E
10F9:  BSF    0A.4
10FA:  BTFSC  27.7
10FB:  BSF    0B.7
10FC:  CLRF   27
10FD:  BTFSC  0B.7
10FE:  BSF    27.7
10FF:  BCF    0B.7
1100:  MOVF   7A,W
1101:  BSF    03.5
1102:  MOVWF  2E
1103:  MOVF   79,W
1104:  MOVWF  2D
1105:  MOVF   78,W
1106:  MOVWF  2C
1107:  MOVF   77,W
1108:  MOVWF  2B
1109:  CLRF   32
110A:  MOVLW  C0
110B:  MOVWF  31
110C:  MOVLW  7F
110D:  MOVWF  30
110E:  MOVLW  88
110F:  MOVWF  2F
1110:  BCF    0A.4
1111:  BCF    03.5
1112:  CALL   53D
1113:  BSF    0A.4
1114:  BTFSC  27.7
1115:  BSF    0B.7
1116:  MOVF   77,W
1117:  MOVWF  68
1118:  MOVF   78,W
1119:  MOVWF  69
111A:  MOVF   79,W
111B:  MOVWF  6A
111C:  MOVF   7A,W
111D:  MOVWF  6B
111E:  CLRF   27
111F:  BTFSC  0B.7
1120:  BSF    27.7
1121:  BCF    0B.7
1122:  MOVF   6B,W
1123:  BSF    03.5
1124:  MOVWF  3B
1125:  BCF    03.5
1126:  MOVF   6A,W
1127:  BSF    03.5
1128:  MOVWF  3A
1129:  BCF    03.5
112A:  MOVF   69,W
112B:  BSF    03.5
112C:  MOVWF  39
112D:  BCF    03.5
112E:  MOVF   68,W
112F:  BSF    03.5
1130:  MOVWF  38
1131:  CLRF   3F
1132:  CLRF   3E
1133:  MOVLW  20
1134:  MOVWF  3D
1135:  MOVLW  81
1136:  MOVWF  3C
1137:  BCF    0A.4
1138:  BCF    03.5
1139:  CALL   36C
113A:  BSF    0A.4
113B:  BTFSC  27.7
113C:  BSF    0B.7
113D:  MOVF   77,W
113E:  MOVWF  68
113F:  MOVF   78,W
1140:  MOVWF  69
1141:  MOVF   79,W
1142:  MOVWF  6A
1143:  MOVF   7A,W
1144:  MOVWF  6B
1145:  MOVLW  73
1146:  BSF    03.6
1147:  MOVWF  0D
1148:  MOVLW  00
1149:  MOVWF  0F
114A:  BCF    03.0
114B:  BCF    03.6
114C:  CLRF   27
114D:  BTFSC  0B.7
114E:  BSF    27.7
114F:  BCF    0B.7
1150:  MOVLW  0B
1151:  BSF    03.5
1152:  MOVWF  2B
1153:  BCF    0A.4
1154:  BCF    03.5
1155:  CALL   30B
1156:  BSF    0A.4
1157:  BTFSC  27.7
1158:  BSF    0B.7
1159:  MOVLW  01
115A:  MOVWF  04
115B:  CLRF   27
115C:  BTFSC  0B.7
115D:  BSF    27.7
115E:  BCF    0B.7
115F:  MOVF   6B,W
1160:  BSF    03.5
1161:  MOVWF  2E
1162:  BCF    03.5
1163:  MOVF   6A,W
1164:  BSF    03.5
1165:  MOVWF  2D
1166:  BCF    03.5
1167:  MOVF   69,W
1168:  BSF    03.5
1169:  MOVWF  2C
116A:  BCF    03.5
116B:  MOVF   68,W
116C:  BSF    03.5
116D:  MOVWF  2B
116E:  MOVLW  01
116F:  MOVWF  2F
1170:  BCF    0A.4
1171:  BCF    03.5
1172:  CALL   427
1173:  BSF    0A.4
1174:  BTFSC  27.7
1175:  BSF    0B.7
1176:  CLRF   27
1177:  BTFSC  0B.7
1178:  BSF    27.7
1179:  BCF    0B.7
117A:  MOVLW  76
117B:  BSF    03.5
117C:  MOVWF  38
117D:  BCF    0A.4
117E:  BCF    03.5
117F:  CALL   1DF
1180:  BSF    0A.4
1181:  BTFSC  27.7
1182:  BSF    0B.7
1183:  CLRF   27
1184:  BTFSC  0B.7
1185:  BSF    27.7
1186:  BCF    0B.7
1187:  MOVLW  0A
1188:  BSF    03.5
1189:  MOVWF  38
118A:  BCF    0A.4
118B:  BCF    03.5
118C:  CALL   1DF
118D:  BSF    0A.4
118E:  BTFSC  27.7
118F:  BSF    0B.7
....................     break; 
1190:  GOTO   5EB
....................      
....................     case 2: 
....................      
....................       Flag_Show = 0; 
1191:  BCF    2A.3
....................       Vch1 = drv_gpio_adc_read(1); 
1192:  MOVLW  01
1193:  MOVWF  68
1194:  BCF    0A.4
1195:  BSF    0A.3
1196:  CALL   382
1197:  BSF    0A.4
1198:  BCF    0A.3
1199:  MOVF   79,W
119A:  MOVWF  3A
119B:  MOVF   78,W
119C:  MOVWF  39
119D:  CLRF   27
119E:  BTFSC  0B.7
119F:  BSF    27.7
11A0:  BCF    0B.7
....................       printf(lcd_putc,"\fALTERNAD.: %2.1fv\n",((Vch1*3.2)/1023.0)*5); 
11A1:  MOVF   3A,W
11A2:  BSF    03.5
11A3:  MOVWF  2C
11A4:  BCF    03.5
11A5:  MOVF   39,W
11A6:  BSF    03.5
11A7:  MOVWF  2B
11A8:  BCF    0A.4
11A9:  BCF    03.5
11AA:  CALL   51E
11AB:  BSF    0A.4
11AC:  BTFSC  27.7
11AD:  BSF    0B.7
11AE:  CLRF   27
11AF:  BTFSC  0B.7
11B0:  BSF    27.7
11B1:  BCF    0B.7
11B2:  MOVF   7A,W
11B3:  BSF    03.5
11B4:  MOVWF  3B
11B5:  MOVF   79,W
11B6:  MOVWF  3A
11B7:  MOVF   78,W
11B8:  MOVWF  39
11B9:  MOVF   77,W
11BA:  MOVWF  38
11BB:  MOVLW  CD
11BC:  MOVWF  3F
11BD:  MOVLW  CC
11BE:  MOVWF  3E
11BF:  MOVLW  4C
11C0:  MOVWF  3D
11C1:  MOVLW  80
11C2:  MOVWF  3C
11C3:  BCF    0A.4
11C4:  BCF    03.5
11C5:  CALL   36C
11C6:  BSF    0A.4
11C7:  BTFSC  27.7
11C8:  BSF    0B.7
11C9:  MOVF   77,W
11CA:  MOVWF  68
11CB:  MOVF   78,W
11CC:  MOVWF  69
11CD:  MOVF   79,W
11CE:  MOVWF  6A
11CF:  MOVF   7A,W
11D0:  MOVWF  6B
11D1:  CLRF   27
11D2:  BTFSC  0B.7
11D3:  BSF    27.7
11D4:  BCF    0B.7
11D5:  MOVF   6B,W
11D6:  BSF    03.5
11D7:  MOVWF  2E
11D8:  BCF    03.5
11D9:  MOVF   6A,W
11DA:  BSF    03.5
11DB:  MOVWF  2D
11DC:  BCF    03.5
11DD:  MOVF   69,W
11DE:  BSF    03.5
11DF:  MOVWF  2C
11E0:  BCF    03.5
11E1:  MOVF   68,W
11E2:  BSF    03.5
11E3:  MOVWF  2B
11E4:  CLRF   32
11E5:  MOVLW  C0
11E6:  MOVWF  31
11E7:  MOVLW  7F
11E8:  MOVWF  30
11E9:  MOVLW  88
11EA:  MOVWF  2F
11EB:  BCF    0A.4
11EC:  BCF    03.5
11ED:  CALL   53D
11EE:  BSF    0A.4
11EF:  BTFSC  27.7
11F0:  BSF    0B.7
11F1:  MOVF   77,W
11F2:  MOVWF  68
11F3:  MOVF   78,W
11F4:  MOVWF  69
11F5:  MOVF   79,W
11F6:  MOVWF  6A
11F7:  MOVF   7A,W
11F8:  MOVWF  6B
11F9:  CLRF   27
11FA:  BTFSC  0B.7
11FB:  BSF    27.7
11FC:  BCF    0B.7
11FD:  MOVF   6B,W
11FE:  BSF    03.5
11FF:  MOVWF  3B
1200:  BCF    03.5
1201:  MOVF   6A,W
1202:  BSF    03.5
1203:  MOVWF  3A
1204:  BCF    03.5
1205:  MOVF   69,W
1206:  BSF    03.5
1207:  MOVWF  39
1208:  BCF    03.5
1209:  MOVF   68,W
120A:  BSF    03.5
120B:  MOVWF  38
120C:  CLRF   3F
120D:  CLRF   3E
120E:  MOVLW  20
120F:  MOVWF  3D
1210:  MOVLW  81
1211:  MOVWF  3C
1212:  BCF    0A.4
1213:  BCF    03.5
1214:  CALL   36C
1215:  BSF    0A.4
1216:  BTFSC  27.7
1217:  BSF    0B.7
1218:  MOVF   77,W
1219:  MOVWF  68
121A:  MOVF   78,W
121B:  MOVWF  69
121C:  MOVF   79,W
121D:  MOVWF  6A
121E:  MOVF   7A,W
121F:  MOVWF  6B
1220:  MOVLW  7D
1221:  BSF    03.6
1222:  MOVWF  0D
1223:  MOVLW  00
1224:  MOVWF  0F
1225:  BCF    03.0
1226:  BCF    03.6
1227:  CLRF   27
1228:  BTFSC  0B.7
1229:  BSF    27.7
122A:  BCF    0B.7
122B:  MOVLW  0C
122C:  BSF    03.5
122D:  MOVWF  2B
122E:  BCF    0A.4
122F:  BCF    03.5
1230:  CALL   30B
1231:  BSF    0A.4
1232:  BTFSC  27.7
1233:  BSF    0B.7
1234:  MOVLW  01
1235:  MOVWF  04
1236:  CLRF   27
1237:  BTFSC  0B.7
1238:  BSF    27.7
1239:  BCF    0B.7
123A:  MOVF   6B,W
123B:  BSF    03.5
123C:  MOVWF  2E
123D:  BCF    03.5
123E:  MOVF   6A,W
123F:  BSF    03.5
1240:  MOVWF  2D
1241:  BCF    03.5
1242:  MOVF   69,W
1243:  BSF    03.5
1244:  MOVWF  2C
1245:  BCF    03.5
1246:  MOVF   68,W
1247:  BSF    03.5
1248:  MOVWF  2B
1249:  MOVLW  01
124A:  MOVWF  2F
124B:  BCF    0A.4
124C:  BCF    03.5
124D:  CALL   427
124E:  BSF    0A.4
124F:  BTFSC  27.7
1250:  BSF    0B.7
1251:  CLRF   27
1252:  BTFSC  0B.7
1253:  BSF    27.7
1254:  BCF    0B.7
1255:  MOVLW  76
1256:  BSF    03.5
1257:  MOVWF  38
1258:  BCF    0A.4
1259:  BCF    03.5
125A:  CALL   1DF
125B:  BSF    0A.4
125C:  BTFSC  27.7
125D:  BSF    0B.7
125E:  CLRF   27
125F:  BTFSC  0B.7
1260:  BSF    27.7
1261:  BCF    0B.7
1262:  MOVLW  0A
1263:  BSF    03.5
1264:  MOVWF  38
1265:  BCF    0A.4
1266:  BCF    03.5
1267:  CALL   1DF
1268:  BSF    0A.4
1269:  BTFSC  27.7
126A:  BSF    0B.7
....................     break; 
126B:  GOTO   5EB
....................      
....................     case 3: 
....................      
....................       Flag_Show = 0; 
126C:  BCF    2A.3
....................       Vch1 = drv_gpio_adc_read(2); 
126D:  MOVLW  02
126E:  MOVWF  68
126F:  BCF    0A.4
1270:  BSF    0A.3
1271:  CALL   382
1272:  BSF    0A.4
1273:  BCF    0A.3
1274:  MOVF   79,W
1275:  MOVWF  3A
1276:  MOVF   78,W
1277:  MOVWF  39
....................       Vch2 = drv_gpio_adc_read(3); 
1278:  MOVLW  03
1279:  MOVWF  68
127A:  BCF    0A.4
127B:  BSF    0A.3
127C:  CALL   382
127D:  BSF    0A.4
127E:  BCF    0A.3
127F:  MOVF   79,W
1280:  MOVWF  3C
1281:  MOVF   78,W
1282:  MOVWF  3B
1283:  CLRF   27
1284:  BTFSC  0B.7
1285:  BSF    27.7
1286:  BCF    0B.7
....................       delay_ms(1); 
1287:  MOVLW  01
1288:  BSF    03.5
1289:  MOVWF  39
128A:  BCF    0A.4
128B:  BCF    03.5
128C:  CALL   1CA
128D:  BSF    0A.4
128E:  BTFSC  27.7
128F:  BSF    0B.7
1290:  CLRF   27
1291:  BTFSC  0B.7
1292:  BSF    27.7
1293:  BCF    0B.7
....................        
....................       printf(lcd_putc,"\fGEN_F1 : %2.1fv\n",((Vch1*37.6)/1023.0)*5); 
1294:  MOVF   3A,W
1295:  BSF    03.5
1296:  MOVWF  2C
1297:  BCF    03.5
1298:  MOVF   39,W
1299:  BSF    03.5
129A:  MOVWF  2B
129B:  BCF    0A.4
129C:  BCF    03.5
129D:  CALL   51E
129E:  BSF    0A.4
129F:  BTFSC  27.7
12A0:  BSF    0B.7
12A1:  CLRF   27
12A2:  BTFSC  0B.7
12A3:  BSF    27.7
12A4:  BCF    0B.7
12A5:  MOVF   7A,W
12A6:  BSF    03.5
12A7:  MOVWF  3B
12A8:  MOVF   79,W
12A9:  MOVWF  3A
12AA:  MOVF   78,W
12AB:  MOVWF  39
12AC:  MOVF   77,W
12AD:  MOVWF  38
12AE:  MOVLW  66
12AF:  MOVWF  3F
12B0:  MOVWF  3E
12B1:  MOVLW  16
12B2:  MOVWF  3D
12B3:  MOVLW  84
12B4:  MOVWF  3C
12B5:  BCF    0A.4
12B6:  BCF    03.5
12B7:  CALL   36C
12B8:  BSF    0A.4
12B9:  BTFSC  27.7
12BA:  BSF    0B.7
12BB:  MOVF   77,W
12BC:  MOVWF  68
12BD:  MOVF   78,W
12BE:  MOVWF  69
12BF:  MOVF   79,W
12C0:  MOVWF  6A
12C1:  MOVF   7A,W
12C2:  MOVWF  6B
12C3:  CLRF   27
12C4:  BTFSC  0B.7
12C5:  BSF    27.7
12C6:  BCF    0B.7
12C7:  MOVF   6B,W
12C8:  BSF    03.5
12C9:  MOVWF  2E
12CA:  BCF    03.5
12CB:  MOVF   6A,W
12CC:  BSF    03.5
12CD:  MOVWF  2D
12CE:  BCF    03.5
12CF:  MOVF   69,W
12D0:  BSF    03.5
12D1:  MOVWF  2C
12D2:  BCF    03.5
12D3:  MOVF   68,W
12D4:  BSF    03.5
12D5:  MOVWF  2B
12D6:  CLRF   32
12D7:  MOVLW  C0
12D8:  MOVWF  31
12D9:  MOVLW  7F
12DA:  MOVWF  30
12DB:  MOVLW  88
12DC:  MOVWF  2F
12DD:  BCF    0A.4
12DE:  BCF    03.5
12DF:  CALL   53D
12E0:  BSF    0A.4
12E1:  BTFSC  27.7
12E2:  BSF    0B.7
12E3:  MOVF   77,W
12E4:  MOVWF  68
12E5:  MOVF   78,W
12E6:  MOVWF  69
12E7:  MOVF   79,W
12E8:  MOVWF  6A
12E9:  MOVF   7A,W
12EA:  MOVWF  6B
12EB:  CLRF   27
12EC:  BTFSC  0B.7
12ED:  BSF    27.7
12EE:  BCF    0B.7
12EF:  MOVF   6B,W
12F0:  BSF    03.5
12F1:  MOVWF  3B
12F2:  BCF    03.5
12F3:  MOVF   6A,W
12F4:  BSF    03.5
12F5:  MOVWF  3A
12F6:  BCF    03.5
12F7:  MOVF   69,W
12F8:  BSF    03.5
12F9:  MOVWF  39
12FA:  BCF    03.5
12FB:  MOVF   68,W
12FC:  BSF    03.5
12FD:  MOVWF  38
12FE:  CLRF   3F
12FF:  CLRF   3E
1300:  MOVLW  20
1301:  MOVWF  3D
1302:  MOVLW  81
1303:  MOVWF  3C
1304:  BCF    0A.4
1305:  BCF    03.5
1306:  CALL   36C
1307:  BSF    0A.4
1308:  BTFSC  27.7
1309:  BSF    0B.7
130A:  MOVF   77,W
130B:  MOVWF  68
130C:  MOVF   78,W
130D:  MOVWF  69
130E:  MOVF   79,W
130F:  MOVWF  6A
1310:  MOVF   7A,W
1311:  MOVWF  6B
1312:  MOVLW  87
1313:  BSF    03.6
1314:  MOVWF  0D
1315:  MOVLW  00
1316:  MOVWF  0F
1317:  BCF    03.0
1318:  BCF    03.6
1319:  CLRF   27
131A:  BTFSC  0B.7
131B:  BSF    27.7
131C:  BCF    0B.7
131D:  MOVLW  0A
131E:  BSF    03.5
131F:  MOVWF  2B
1320:  BCF    0A.4
1321:  BCF    03.5
1322:  CALL   30B
1323:  BSF    0A.4
1324:  BTFSC  27.7
1325:  BSF    0B.7
1326:  MOVLW  01
1327:  MOVWF  04
1328:  CLRF   27
1329:  BTFSC  0B.7
132A:  BSF    27.7
132B:  BCF    0B.7
132C:  MOVF   6B,W
132D:  BSF    03.5
132E:  MOVWF  2E
132F:  BCF    03.5
1330:  MOVF   6A,W
1331:  BSF    03.5
1332:  MOVWF  2D
1333:  BCF    03.5
1334:  MOVF   69,W
1335:  BSF    03.5
1336:  MOVWF  2C
1337:  BCF    03.5
1338:  MOVF   68,W
1339:  BSF    03.5
133A:  MOVWF  2B
133B:  MOVLW  01
133C:  MOVWF  2F
133D:  BCF    0A.4
133E:  BCF    03.5
133F:  CALL   427
1340:  BSF    0A.4
1341:  BTFSC  27.7
1342:  BSF    0B.7
1343:  CLRF   27
1344:  BTFSC  0B.7
1345:  BSF    27.7
1346:  BCF    0B.7
1347:  MOVLW  76
1348:  BSF    03.5
1349:  MOVWF  38
134A:  BCF    0A.4
134B:  BCF    03.5
134C:  CALL   1DF
134D:  BSF    0A.4
134E:  BTFSC  27.7
134F:  BSF    0B.7
1350:  CLRF   27
1351:  BTFSC  0B.7
1352:  BSF    27.7
1353:  BCF    0B.7
1354:  MOVLW  0A
1355:  BSF    03.5
1356:  MOVWF  38
1357:  BCF    0A.4
1358:  BCF    03.5
1359:  CALL   1DF
135A:  BSF    0A.4
135B:  BTFSC  27.7
135C:  BSF    0B.7
135D:  CLRF   27
135E:  BTFSC  0B.7
135F:  BSF    27.7
1360:  BCF    0B.7
....................       printf(lcd_putc,"GEN_F2: %2.1fv\n",((Vch2*37.6)/1023.0)*5); 
1361:  MOVF   3C,W
1362:  BSF    03.5
1363:  MOVWF  2C
1364:  BCF    03.5
1365:  MOVF   3B,W
1366:  BSF    03.5
1367:  MOVWF  2B
1368:  BCF    0A.4
1369:  BCF    03.5
136A:  CALL   51E
136B:  BSF    0A.4
136C:  BTFSC  27.7
136D:  BSF    0B.7
136E:  CLRF   27
136F:  BTFSC  0B.7
1370:  BSF    27.7
1371:  BCF    0B.7
1372:  MOVF   7A,W
1373:  BSF    03.5
1374:  MOVWF  3B
1375:  MOVF   79,W
1376:  MOVWF  3A
1377:  MOVF   78,W
1378:  MOVWF  39
1379:  MOVF   77,W
137A:  MOVWF  38
137B:  MOVLW  66
137C:  MOVWF  3F
137D:  MOVWF  3E
137E:  MOVLW  16
137F:  MOVWF  3D
1380:  MOVLW  84
1381:  MOVWF  3C
1382:  BCF    0A.4
1383:  BCF    03.5
1384:  CALL   36C
1385:  BSF    0A.4
1386:  BTFSC  27.7
1387:  BSF    0B.7
1388:  MOVF   77,W
1389:  MOVWF  68
138A:  MOVF   78,W
138B:  MOVWF  69
138C:  MOVF   79,W
138D:  MOVWF  6A
138E:  MOVF   7A,W
138F:  MOVWF  6B
1390:  CLRF   27
1391:  BTFSC  0B.7
1392:  BSF    27.7
1393:  BCF    0B.7
1394:  MOVF   6B,W
1395:  BSF    03.5
1396:  MOVWF  2E
1397:  BCF    03.5
1398:  MOVF   6A,W
1399:  BSF    03.5
139A:  MOVWF  2D
139B:  BCF    03.5
139C:  MOVF   69,W
139D:  BSF    03.5
139E:  MOVWF  2C
139F:  BCF    03.5
13A0:  MOVF   68,W
13A1:  BSF    03.5
13A2:  MOVWF  2B
13A3:  CLRF   32
13A4:  MOVLW  C0
13A5:  MOVWF  31
13A6:  MOVLW  7F
13A7:  MOVWF  30
13A8:  MOVLW  88
13A9:  MOVWF  2F
13AA:  BCF    0A.4
13AB:  BCF    03.5
13AC:  CALL   53D
13AD:  BSF    0A.4
13AE:  BTFSC  27.7
13AF:  BSF    0B.7
13B0:  MOVF   77,W
13B1:  MOVWF  68
13B2:  MOVF   78,W
13B3:  MOVWF  69
13B4:  MOVF   79,W
13B5:  MOVWF  6A
13B6:  MOVF   7A,W
13B7:  MOVWF  6B
13B8:  CLRF   27
13B9:  BTFSC  0B.7
13BA:  BSF    27.7
13BB:  BCF    0B.7
13BC:  MOVF   6B,W
13BD:  BSF    03.5
13BE:  MOVWF  3B
13BF:  BCF    03.5
13C0:  MOVF   6A,W
13C1:  BSF    03.5
13C2:  MOVWF  3A
13C3:  BCF    03.5
13C4:  MOVF   69,W
13C5:  BSF    03.5
13C6:  MOVWF  39
13C7:  BCF    03.5
13C8:  MOVF   68,W
13C9:  BSF    03.5
13CA:  MOVWF  38
13CB:  CLRF   3F
13CC:  CLRF   3E
13CD:  MOVLW  20
13CE:  MOVWF  3D
13CF:  MOVLW  81
13D0:  MOVWF  3C
13D1:  BCF    0A.4
13D2:  BCF    03.5
13D3:  CALL   36C
13D4:  BSF    0A.4
13D5:  BTFSC  27.7
13D6:  BSF    0B.7
13D7:  MOVF   77,W
13D8:  MOVWF  68
13D9:  MOVF   78,W
13DA:  MOVWF  69
13DB:  MOVF   79,W
13DC:  MOVWF  6A
13DD:  MOVF   7A,W
13DE:  MOVWF  6B
13DF:  MOVLW  90
13E0:  BSF    03.6
13E1:  MOVWF  0D
13E2:  MOVLW  00
13E3:  MOVWF  0F
13E4:  BCF    03.0
13E5:  BCF    03.6
13E6:  CLRF   27
13E7:  BTFSC  0B.7
13E8:  BSF    27.7
13E9:  BCF    0B.7
13EA:  MOVLW  08
13EB:  BSF    03.5
13EC:  MOVWF  2B
13ED:  BCF    0A.4
13EE:  BCF    03.5
13EF:  CALL   30B
13F0:  BSF    0A.4
13F1:  BTFSC  27.7
13F2:  BSF    0B.7
13F3:  MOVLW  01
13F4:  MOVWF  04
13F5:  CLRF   27
13F6:  BTFSC  0B.7
13F7:  BSF    27.7
13F8:  BCF    0B.7
13F9:  MOVF   6B,W
13FA:  BSF    03.5
13FB:  MOVWF  2E
13FC:  BCF    03.5
13FD:  MOVF   6A,W
13FE:  BSF    03.5
13FF:  MOVWF  2D
1400:  BCF    03.5
1401:  MOVF   69,W
1402:  BSF    03.5
1403:  MOVWF  2C
1404:  BCF    03.5
1405:  MOVF   68,W
1406:  BSF    03.5
1407:  MOVWF  2B
1408:  MOVLW  01
1409:  MOVWF  2F
140A:  BCF    0A.4
140B:  BCF    03.5
140C:  CALL   427
140D:  BSF    0A.4
140E:  BTFSC  27.7
140F:  BSF    0B.7
1410:  CLRF   27
1411:  BTFSC  0B.7
1412:  BSF    27.7
1413:  BCF    0B.7
1414:  MOVLW  76
1415:  BSF    03.5
1416:  MOVWF  38
1417:  BCF    0A.4
1418:  BCF    03.5
1419:  CALL   1DF
141A:  BSF    0A.4
141B:  BTFSC  27.7
141C:  BSF    0B.7
141D:  CLRF   27
141E:  BTFSC  0B.7
141F:  BSF    27.7
1420:  BCF    0B.7
1421:  MOVLW  0A
1422:  BSF    03.5
1423:  MOVWF  38
1424:  BCF    0A.4
1425:  BCF    03.5
1426:  CALL   1DF
1427:  BSF    0A.4
1428:  BTFSC  27.7
1429:  BSF    0B.7
....................       //delay_ms(100); 
....................     break; 
142A:  GOTO   5EB
....................      
....................     case 4: 
....................      
....................       Flag_Show = 0; 
142B:  BCF    2A.3
....................       Vch1 = drv_gpio_adc_read(4); 
142C:  MOVLW  04
142D:  MOVWF  68
142E:  BCF    0A.4
142F:  BSF    0A.3
1430:  CALL   382
1431:  BSF    0A.4
1432:  BCF    0A.3
1433:  MOVF   79,W
1434:  MOVWF  3A
1435:  MOVF   78,W
1436:  MOVWF  39
....................       Vch2 = drv_gpio_adc_read(5); 
1437:  MOVLW  05
1438:  MOVWF  68
1439:  BCF    0A.4
143A:  BSF    0A.3
143B:  CALL   382
143C:  BSF    0A.4
143D:  BCF    0A.3
143E:  MOVF   79,W
143F:  MOVWF  3C
1440:  MOVF   78,W
1441:  MOVWF  3B
1442:  CLRF   27
1443:  BTFSC  0B.7
1444:  BSF    27.7
1445:  BCF    0B.7
....................       delay_ms(1); 
1446:  MOVLW  01
1447:  BSF    03.5
1448:  MOVWF  39
1449:  BCF    0A.4
144A:  BCF    03.5
144B:  CALL   1CA
144C:  BSF    0A.4
144D:  BTFSC  27.7
144E:  BSF    0B.7
144F:  CLRF   27
1450:  BTFSC  0B.7
1451:  BSF    27.7
1452:  BCF    0B.7
....................        
....................       printf(lcd_putc,"\fCALL_F1 : %2.1fv\n",((Vch1*37.6)/1023.0)*5); 
1453:  MOVF   3A,W
1454:  BSF    03.5
1455:  MOVWF  2C
1456:  BCF    03.5
1457:  MOVF   39,W
1458:  BSF    03.5
1459:  MOVWF  2B
145A:  BCF    0A.4
145B:  BCF    03.5
145C:  CALL   51E
145D:  BSF    0A.4
145E:  BTFSC  27.7
145F:  BSF    0B.7
1460:  CLRF   27
1461:  BTFSC  0B.7
1462:  BSF    27.7
1463:  BCF    0B.7
1464:  MOVF   7A,W
1465:  BSF    03.5
1466:  MOVWF  3B
1467:  MOVF   79,W
1468:  MOVWF  3A
1469:  MOVF   78,W
146A:  MOVWF  39
146B:  MOVF   77,W
146C:  MOVWF  38
146D:  MOVLW  66
146E:  MOVWF  3F
146F:  MOVWF  3E
1470:  MOVLW  16
1471:  MOVWF  3D
1472:  MOVLW  84
1473:  MOVWF  3C
1474:  BCF    0A.4
1475:  BCF    03.5
1476:  CALL   36C
1477:  BSF    0A.4
1478:  BTFSC  27.7
1479:  BSF    0B.7
147A:  MOVF   77,W
147B:  MOVWF  68
147C:  MOVF   78,W
147D:  MOVWF  69
147E:  MOVF   79,W
147F:  MOVWF  6A
1480:  MOVF   7A,W
1481:  MOVWF  6B
1482:  CLRF   27
1483:  BTFSC  0B.7
1484:  BSF    27.7
1485:  BCF    0B.7
1486:  MOVF   6B,W
1487:  BSF    03.5
1488:  MOVWF  2E
1489:  BCF    03.5
148A:  MOVF   6A,W
148B:  BSF    03.5
148C:  MOVWF  2D
148D:  BCF    03.5
148E:  MOVF   69,W
148F:  BSF    03.5
1490:  MOVWF  2C
1491:  BCF    03.5
1492:  MOVF   68,W
1493:  BSF    03.5
1494:  MOVWF  2B
1495:  CLRF   32
1496:  MOVLW  C0
1497:  MOVWF  31
1498:  MOVLW  7F
1499:  MOVWF  30
149A:  MOVLW  88
149B:  MOVWF  2F
149C:  BCF    0A.4
149D:  BCF    03.5
149E:  CALL   53D
149F:  BSF    0A.4
14A0:  BTFSC  27.7
14A1:  BSF    0B.7
14A2:  MOVF   77,W
14A3:  MOVWF  68
14A4:  MOVF   78,W
14A5:  MOVWF  69
14A6:  MOVF   79,W
14A7:  MOVWF  6A
14A8:  MOVF   7A,W
14A9:  MOVWF  6B
14AA:  CLRF   27
14AB:  BTFSC  0B.7
14AC:  BSF    27.7
14AD:  BCF    0B.7
14AE:  MOVF   6B,W
14AF:  BSF    03.5
14B0:  MOVWF  3B
14B1:  BCF    03.5
14B2:  MOVF   6A,W
14B3:  BSF    03.5
14B4:  MOVWF  3A
14B5:  BCF    03.5
14B6:  MOVF   69,W
14B7:  BSF    03.5
14B8:  MOVWF  39
14B9:  BCF    03.5
14BA:  MOVF   68,W
14BB:  BSF    03.5
14BC:  MOVWF  38
14BD:  CLRF   3F
14BE:  CLRF   3E
14BF:  MOVLW  20
14C0:  MOVWF  3D
14C1:  MOVLW  81
14C2:  MOVWF  3C
14C3:  BCF    0A.4
14C4:  BCF    03.5
14C5:  CALL   36C
14C6:  BSF    0A.4
14C7:  BTFSC  27.7
14C8:  BSF    0B.7
14C9:  MOVF   77,W
14CA:  MOVWF  68
14CB:  MOVF   78,W
14CC:  MOVWF  69
14CD:  MOVF   79,W
14CE:  MOVWF  6A
14CF:  MOVF   7A,W
14D0:  MOVWF  6B
14D1:  MOVLW  98
14D2:  BSF    03.6
14D3:  MOVWF  0D
14D4:  MOVLW  00
14D5:  MOVWF  0F
14D6:  BCF    03.0
14D7:  BCF    03.6
14D8:  CLRF   27
14D9:  BTFSC  0B.7
14DA:  BSF    27.7
14DB:  BCF    0B.7
14DC:  MOVLW  0B
14DD:  BSF    03.5
14DE:  MOVWF  2B
14DF:  BCF    0A.4
14E0:  BCF    03.5
14E1:  CALL   30B
14E2:  BSF    0A.4
14E3:  BTFSC  27.7
14E4:  BSF    0B.7
14E5:  MOVLW  01
14E6:  MOVWF  04
14E7:  CLRF   27
14E8:  BTFSC  0B.7
14E9:  BSF    27.7
14EA:  BCF    0B.7
14EB:  MOVF   6B,W
14EC:  BSF    03.5
14ED:  MOVWF  2E
14EE:  BCF    03.5
14EF:  MOVF   6A,W
14F0:  BSF    03.5
14F1:  MOVWF  2D
14F2:  BCF    03.5
14F3:  MOVF   69,W
14F4:  BSF    03.5
14F5:  MOVWF  2C
14F6:  BCF    03.5
14F7:  MOVF   68,W
14F8:  BSF    03.5
14F9:  MOVWF  2B
14FA:  MOVLW  01
14FB:  MOVWF  2F
14FC:  BCF    0A.4
14FD:  BCF    03.5
14FE:  CALL   427
14FF:  BSF    0A.4
1500:  BTFSC  27.7
1501:  BSF    0B.7
1502:  CLRF   27
1503:  BTFSC  0B.7
1504:  BSF    27.7
1505:  BCF    0B.7
1506:  MOVLW  76
1507:  BSF    03.5
1508:  MOVWF  38
1509:  BCF    0A.4
150A:  BCF    03.5
150B:  CALL   1DF
150C:  BSF    0A.4
150D:  BTFSC  27.7
150E:  BSF    0B.7
150F:  CLRF   27
1510:  BTFSC  0B.7
1511:  BSF    27.7
1512:  BCF    0B.7
1513:  MOVLW  0A
1514:  BSF    03.5
1515:  MOVWF  38
1516:  BCF    0A.4
1517:  BCF    03.5
1518:  CALL   1DF
1519:  BSF    0A.4
151A:  BTFSC  27.7
151B:  BSF    0B.7
151C:  CLRF   27
151D:  BTFSC  0B.7
151E:  BSF    27.7
151F:  BCF    0B.7
....................       printf(lcd_putc,"CALL_F2: %2.1fv\n",((Vch2*37.6)/1023.0)*5); 
1520:  MOVF   3C,W
1521:  BSF    03.5
1522:  MOVWF  2C
1523:  BCF    03.5
1524:  MOVF   3B,W
1525:  BSF    03.5
1526:  MOVWF  2B
1527:  BCF    0A.4
1528:  BCF    03.5
1529:  CALL   51E
152A:  BSF    0A.4
152B:  BTFSC  27.7
152C:  BSF    0B.7
152D:  CLRF   27
152E:  BTFSC  0B.7
152F:  BSF    27.7
1530:  BCF    0B.7
1531:  MOVF   7A,W
1532:  BSF    03.5
1533:  MOVWF  3B
1534:  MOVF   79,W
1535:  MOVWF  3A
1536:  MOVF   78,W
1537:  MOVWF  39
1538:  MOVF   77,W
1539:  MOVWF  38
153A:  MOVLW  66
153B:  MOVWF  3F
153C:  MOVWF  3E
153D:  MOVLW  16
153E:  MOVWF  3D
153F:  MOVLW  84
1540:  MOVWF  3C
1541:  BCF    0A.4
1542:  BCF    03.5
1543:  CALL   36C
1544:  BSF    0A.4
1545:  BTFSC  27.7
1546:  BSF    0B.7
1547:  MOVF   77,W
1548:  MOVWF  68
1549:  MOVF   78,W
154A:  MOVWF  69
154B:  MOVF   79,W
154C:  MOVWF  6A
154D:  MOVF   7A,W
154E:  MOVWF  6B
154F:  CLRF   27
1550:  BTFSC  0B.7
1551:  BSF    27.7
1552:  BCF    0B.7
1553:  MOVF   6B,W
1554:  BSF    03.5
1555:  MOVWF  2E
1556:  BCF    03.5
1557:  MOVF   6A,W
1558:  BSF    03.5
1559:  MOVWF  2D
155A:  BCF    03.5
155B:  MOVF   69,W
155C:  BSF    03.5
155D:  MOVWF  2C
155E:  BCF    03.5
155F:  MOVF   68,W
1560:  BSF    03.5
1561:  MOVWF  2B
1562:  CLRF   32
1563:  MOVLW  C0
1564:  MOVWF  31
1565:  MOVLW  7F
1566:  MOVWF  30
1567:  MOVLW  88
1568:  MOVWF  2F
1569:  BCF    0A.4
156A:  BCF    03.5
156B:  CALL   53D
156C:  BSF    0A.4
156D:  BTFSC  27.7
156E:  BSF    0B.7
156F:  MOVF   77,W
1570:  MOVWF  68
1571:  MOVF   78,W
1572:  MOVWF  69
1573:  MOVF   79,W
1574:  MOVWF  6A
1575:  MOVF   7A,W
1576:  MOVWF  6B
1577:  CLRF   27
1578:  BTFSC  0B.7
1579:  BSF    27.7
157A:  BCF    0B.7
157B:  MOVF   6B,W
157C:  BSF    03.5
157D:  MOVWF  3B
157E:  BCF    03.5
157F:  MOVF   6A,W
1580:  BSF    03.5
1581:  MOVWF  3A
1582:  BCF    03.5
1583:  MOVF   69,W
1584:  BSF    03.5
1585:  MOVWF  39
1586:  BCF    03.5
1587:  MOVF   68,W
1588:  BSF    03.5
1589:  MOVWF  38
158A:  CLRF   3F
158B:  CLRF   3E
158C:  MOVLW  20
158D:  MOVWF  3D
158E:  MOVLW  81
158F:  MOVWF  3C
1590:  BCF    0A.4
1591:  BCF    03.5
1592:  CALL   36C
1593:  BSF    0A.4
1594:  BTFSC  27.7
1595:  BSF    0B.7
1596:  MOVF   77,W
1597:  MOVWF  68
1598:  MOVF   78,W
1599:  MOVWF  69
159A:  MOVF   79,W
159B:  MOVWF  6A
159C:  MOVF   7A,W
159D:  MOVWF  6B
159E:  MOVLW  A2
159F:  BSF    03.6
15A0:  MOVWF  0D
15A1:  MOVLW  00
15A2:  MOVWF  0F
15A3:  BCF    03.0
15A4:  BCF    03.6
15A5:  CLRF   27
15A6:  BTFSC  0B.7
15A7:  BSF    27.7
15A8:  BCF    0B.7
15A9:  MOVLW  09
15AA:  BSF    03.5
15AB:  MOVWF  2B
15AC:  BCF    0A.4
15AD:  BCF    03.5
15AE:  CALL   30B
15AF:  BSF    0A.4
15B0:  BTFSC  27.7
15B1:  BSF    0B.7
15B2:  MOVLW  01
15B3:  MOVWF  04
15B4:  CLRF   27
15B5:  BTFSC  0B.7
15B6:  BSF    27.7
15B7:  BCF    0B.7
15B8:  MOVF   6B,W
15B9:  BSF    03.5
15BA:  MOVWF  2E
15BB:  BCF    03.5
15BC:  MOVF   6A,W
15BD:  BSF    03.5
15BE:  MOVWF  2D
15BF:  BCF    03.5
15C0:  MOVF   69,W
15C1:  BSF    03.5
15C2:  MOVWF  2C
15C3:  BCF    03.5
15C4:  MOVF   68,W
15C5:  BSF    03.5
15C6:  MOVWF  2B
15C7:  MOVLW  01
15C8:  MOVWF  2F
15C9:  BCF    0A.4
15CA:  BCF    03.5
15CB:  CALL   427
15CC:  BSF    0A.4
15CD:  BTFSC  27.7
15CE:  BSF    0B.7
15CF:  CLRF   27
15D0:  BTFSC  0B.7
15D1:  BSF    27.7
15D2:  BCF    0B.7
15D3:  MOVLW  76
15D4:  BSF    03.5
15D5:  MOVWF  38
15D6:  BCF    0A.4
15D7:  BCF    03.5
15D8:  CALL   1DF
15D9:  BSF    0A.4
15DA:  BTFSC  27.7
15DB:  BSF    0B.7
15DC:  CLRF   27
15DD:  BTFSC  0B.7
15DE:  BSF    27.7
15DF:  BCF    0B.7
15E0:  MOVLW  0A
15E1:  BSF    03.5
15E2:  MOVWF  38
15E3:  BCF    0A.4
15E4:  BCF    03.5
15E5:  CALL   1DF
15E6:  BSF    0A.4
15E7:  BTFSC  27.7
15E8:  BSF    0B.7
....................       //delay_ms(100); 
....................        
....................        break;  
15E9:  GOTO   5EB
....................      
....................     case 5:  
....................       
....................       break; 
15EA:  GOTO   5EB
....................    }    
.................... } 
15EB:  BSF    0A.3
15EC:  BCF    0A.4
15ED:  GOTO   474 (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void drv_rpm_int_rb(void){} 
....................  
.................... void drv_rpm_int_ext(void){ 
....................  
....................   ++Numero_Flanco;         // Cuento flanco que nos llegan 
*
0809:  INCF   3E,F
*
1007:  INCF   3E,F
....................    
....................    if(Flanco==0){           // He recibido Flanco de Subida 
*
080A:  BTFSC  3D.2
080B:  GOTO   034
*
1008:  BTFSC  3D.2
1009:  GOTO   032
....................       if(Numero_Flanco == 1){// Primer Flanco Alto 
*
080C:  DECFSZ 3E,W
080D:  GOTO   01C
*
100A:  DECFSZ 3E,W
100B:  GOTO   01A
....................          set_timer1(0);       // Reinicio TMR1 
*
080E:  CLRF   0F
080F:  CLRF   0E
*
100C:  CLRF   0F
100D:  CLRF   0E
....................          T1=get_timer1();     // Guardo en T1 el valor de TMR1 al primer  
*
0810:  MOVF   0F,W
0811:  MOVWF  7A
0812:  MOVF   0E,W
0813:  MOVWF  77
0814:  MOVF   0F,W
0815:  SUBWF  7A,W
0816:  BTFSS  03.2
0817:  GOTO   010
0818:  MOVF   77,W
0819:  MOVWF  3F
081A:  MOVF   7A,W
081B:  MOVWF  40
*
100E:  MOVF   0F,W
100F:  MOVWF  7A
1010:  MOVF   0E,W
1011:  MOVWF  77
1012:  MOVF   0F,W
1013:  SUBWF  7A,W
1014:  BTFSS  03.2
1015:  GOTO   00E
1016:  MOVF   77,W
1017:  MOVWF  3F
1018:  MOVF   7A,W
1019:  MOVWF  40
....................     }                      // Flanco de Subida 
....................    if(Numero_Flanco == 3){// Segundo Flanco de subida 
*
081C:  MOVF   3E,W
081D:  SUBLW  03
081E:  BTFSS  03.2
081F:  GOTO   02F
*
101A:  MOVF   3E,W
101B:  SUBLW  03
101C:  BTFSS  03.2
101D:  GOTO   02D
....................          T3=get_timer1();     // Guardo en T3 el valor de TMR1 al primer Flanco de Subida 
*
0820:  MOVF   0F,W
0821:  MOVWF  7A
0822:  MOVF   0E,W
0823:  MOVWF  77
0824:  MOVF   0F,W
0825:  SUBWF  7A,W
0826:  BTFSS  03.2
0827:  GOTO   020
0828:  MOVF   77,W
0829:  MOVWF  43
082A:  MOVF   7A,W
082B:  MOVWF  44
*
101E:  MOVF   0F,W
101F:  MOVWF  7A
1020:  MOVF   0E,W
1021:  MOVWF  77
1022:  MOVF   0F,W
1023:  SUBWF  7A,W
1024:  BTFSS  03.2
1025:  GOTO   01E
1026:  MOVF   77,W
1027:  MOVWF  43
1028:  MOVF   7A,W
1029:  MOVWF  44
....................          if(Completado == 0){ // Si los datos anteriores han sido procesados ... 
*
082C:  BTFSC  3D.1
082D:  GOTO   02F
*
102A:  BTFSC  3D.1
102B:  GOTO   02D
....................          Completado = 1;    // Indico que ya hay nuevos datos de flancos para calcular 
*
082E:  BSF    3D.1
*
102C:  BSF    3D.1
....................       } 
....................     } 
....................     ext_int_edge(0,H_TO_L); // Configuro para capturar siguiente flanco de Bajada 
*
082F:  BSF    03.5
0830:  BCF    01.6
*
102D:  BSF    03.5
102E:  BCF    01.6
....................     Flanco=1;               // Indico que el siguiente flanco ser? de Bajada 
*
0831:  BCF    03.5
0832:  BSF    3D.2
*
102F:  BCF    03.5
1030:  BSF    3D.2
....................  
....................   }  
....................    
....................   else {                    // He recibido Flanco de Bajada 
*
0833:  GOTO   044
*
1031:  GOTO   042
....................       T2=get_timer1();          // Guardo en T2 el valor de TMR1 al Flanco de Bajada 
*
0834:  MOVF   0F,W
0835:  MOVWF  7A
0836:  MOVF   0E,W
0837:  MOVWF  77
0838:  MOVF   0F,W
0839:  SUBWF  7A,W
083A:  BTFSS  03.2
083B:  GOTO   034
083C:  MOVF   77,W
083D:  MOVWF  41
083E:  MOVF   7A,W
083F:  MOVWF  42
*
1032:  MOVF   0F,W
1033:  MOVWF  7A
1034:  MOVF   0E,W
1035:  MOVWF  77
1036:  MOVF   0F,W
1037:  SUBWF  7A,W
1038:  BTFSS  03.2
1039:  GOTO   032
103A:  MOVF   77,W
103B:  MOVWF  41
103C:  MOVF   7A,W
103D:  MOVWF  42
....................       ext_int_edge(0,L_TO_H);   // Configuro para capturar siguiente flanco de subida 
*
0840:  BSF    03.5
0841:  BSF    01.6
*
103E:  BSF    03.5
103F:  BSF    01.6
....................       Flanco=0;                 // Indico que el siguiente flanco ser? de Subida 
*
0842:  BCF    03.5
0843:  BCF    3D.2
*
1040:  BCF    03.5
1041:  BCF    3D.2
....................   } 
....................   if(Numero_Flanco == 3){      
*
0844:  MOVF   3E,W
0845:  SUBLW  03
0846:  BTFSS  03.2
0847:  GOTO   0D8
*
1042:  MOVF   3E,W
1043:  SUBLW  03
1044:  BTFSS  03.2
1045:  GOTO   0D6
....................     Numero_Flanco =0;         
*
0848:  CLRF   3E
*
1046:  CLRF   3E
....................         drv_rpm_show();  
....................   } 
....................    
....................     
....................    
.................... } 
....................  
.................... void drv_rpm_capture(void) 
.................... { 
.................... if ((F==0)||(F==1)){ // si la frecuencia es igial a 0 o 1 
*
0609:  MOVF   45,F
060A:  BTFSS  03.2
060B:  GOTO   60F
060C:  MOVF   46,F
060D:  BTFSC  03.2
060E:  GOTO   614
060F:  DECFSZ 45,W
0610:  GOTO   624
0611:  MOVF   46,F
0612:  BTFSS  03.2
0613:  GOTO   624
....................          set_pwm1_duty(5); // saca el ciclo util minimo 
0614:  MOVLW  05
0615:  MOVWF  15
....................          F = 0;            // y reinicia todas las variables 
0616:  CLRF   46
0617:  CLRF   45
....................          Ta = 0; 
0618:  CLRF   5A
0619:  CLRF   59
061A:  CLRF   58
061B:  CLRF   57
....................          rpm = 0; 
061C:  CLRF   62
061D:  CLRF   61
061E:  CLRF   60
061F:  CLRF   5F
....................          P_ms = 0.00; 
0620:  CLRF   56
0621:  CLRF   55
0622:  CLRF   54
0623:  CLRF   53
....................       } 
....................        
....................       if(Completado==1){               // Detecto que ya hay datos de flancos ... 
0624:  BTFSS  3D.1
0625:  GOTO   713
....................          if((T3>T2)&&(T2>T1)){         // Compruebo que estoy en la misma vuelta de TMR1 
0626:  MOVF   42,W
0627:  SUBWF  44,W
0628:  BTFSS  03.0
0629:  GOTO   712
062A:  BTFSS  03.2
062B:  GOTO   630
062C:  MOVF   43,W
062D:  SUBWF  41,W
062E:  BTFSC  03.0
062F:  GOTO   712
0630:  MOVF   40,W
0631:  SUBWF  42,W
0632:  BTFSS  03.0
0633:  GOTO   712
0634:  BTFSS  03.2
0635:  GOTO   63A
0636:  MOVF   41,W
0637:  SUBWF  3F,W
0638:  BTFSC  03.0
0639:  GOTO   712
....................             T_High = T2 - T1;          // Calculo en Tick's de TMR1 el tiempo en Alto 
063A:  MOVF   3F,W
063B:  SUBWF  41,W
063C:  MOVWF  49
063D:  MOVF   42,W
063E:  MOVWF  4A
063F:  MOVF   40,W
0640:  BTFSS  03.0
0641:  INCFSZ 40,W
0642:  SUBWF  4A,F
....................             T_Low = T3 - T2;           // Calculo en Tick's de TMR1 el tiempo en Bajo 
0643:  MOVF   41,W
0644:  SUBWF  43,W
0645:  MOVWF  4B
0646:  MOVF   44,W
0647:  MOVWF  4C
0648:  MOVF   42,W
0649:  BTFSS  03.0
064A:  INCFSZ 42,W
064B:  SUBWF  4C,F
....................             T_Total = T_High + T_Low;  // Calculo en Tick's de TMR1 el Periodo del Pulso 
064C:  MOVF   4B,W
064D:  ADDWF  49,W
064E:  MOVWF  4D
064F:  MOVF   4A,W
0650:  MOVWF  4E
0651:  MOVF   4C,W
0652:  BTFSC  03.0
0653:  INCFSZ 4C,W
0654:  ADDWF  4E,F
....................             P = 8.0  * T_Total;        // Calculo en uS el tiempo. 
0655:  MOVF   4E,W
0656:  BSF    03.5
0657:  MOVWF  2C
0658:  BCF    03.5
0659:  MOVF   4D,W
065A:  BSF    03.5
065B:  MOVWF  2B
065C:  BCF    03.5
065D:  CALL   51E
065E:  BSF    03.5
065F:  CLRF   3B
0660:  CLRF   3A
0661:  CLRF   39
0662:  MOVLW  82
0663:  MOVWF  38
0664:  MOVF   7A,W
0665:  MOVWF  3F
0666:  MOVF   79,W
0667:  MOVWF  3E
0668:  MOVF   78,W
0669:  MOVWF  3D
066A:  MOVF   77,W
066B:  MOVWF  3C
066C:  BCF    03.5
066D:  CALL   36C
066E:  MOVF   7A,W
066F:  MOVWF  52
0670:  MOVF   79,W
0671:  MOVWF  51
0672:  MOVF   78,W
0673:  MOVWF  50
0674:  MOVF   77,W
0675:  MOVWF  4F
....................             P_ms = P/1000;             // Periodo en milisegundos 
0676:  MOVF   52,W
0677:  BSF    03.5
0678:  MOVWF  2E
0679:  BCF    03.5
067A:  MOVF   51,W
067B:  BSF    03.5
067C:  MOVWF  2D
067D:  BCF    03.5
067E:  MOVF   50,W
067F:  BSF    03.5
0680:  MOVWF  2C
0681:  BCF    03.5
0682:  MOVF   4F,W
0683:  BSF    03.5
0684:  MOVWF  2B
0685:  CLRF   32
0686:  CLRF   31
0687:  MOVLW  7A
0688:  MOVWF  30
0689:  MOVLW  88
068A:  MOVWF  2F
068B:  BCF    03.5
068C:  CALL   53D
068D:  MOVF   7A,W
068E:  MOVWF  56
068F:  MOVF   79,W
0690:  MOVWF  55
0691:  MOVF   78,W
0692:  MOVWF  54
0693:  MOVF   77,W
0694:  MOVWF  53
....................             F = 1 / (P / 1000000);     // Calculo la Frecuencia en segundos 
0695:  MOVF   52,W
0696:  BSF    03.5
0697:  MOVWF  2E
0698:  BCF    03.5
0699:  MOVF   51,W
069A:  BSF    03.5
069B:  MOVWF  2D
069C:  BCF    03.5
069D:  MOVF   50,W
069E:  BSF    03.5
069F:  MOVWF  2C
06A0:  BCF    03.5
06A1:  MOVF   4F,W
06A2:  BSF    03.5
06A3:  MOVWF  2B
06A4:  CLRF   32
06A5:  MOVLW  24
06A6:  MOVWF  31
06A7:  MOVLW  74
06A8:  MOVWF  30
06A9:  MOVLW  92
06AA:  MOVWF  2F
06AB:  BCF    03.5
06AC:  CALL   53D
06AD:  BSF    03.5
06AE:  CLRF   2E
06AF:  CLRF   2D
06B0:  CLRF   2C
06B1:  MOVLW  7F
06B2:  MOVWF  2B
06B3:  MOVF   7A,W
06B4:  MOVWF  32
06B5:  MOVF   79,W
06B6:  MOVWF  31
06B7:  MOVF   78,W
06B8:  MOVWF  30
06B9:  MOVF   77,W
06BA:  MOVWF  2F
06BB:  BCF    03.5
06BC:  CALL   53D
06BD:  MOVF   7A,W
06BE:  BSF    03.5
06BF:  MOVWF  2E
06C0:  MOVF   79,W
06C1:  MOVWF  2D
06C2:  MOVF   78,W
06C3:  MOVWF  2C
06C4:  MOVF   77,W
06C5:  MOVWF  2B
*
06E4:  MOVF   79,W
06E5:  BCF    03.5
06E6:  MOVWF  46
06E7:  MOVF   78,W
06E8:  MOVWF  45
....................             F = F + 1; 
06E9:  MOVLW  01
06EA:  ADDWF  45,F
06EB:  BTFSC  03.0
06EC:  INCF   46,F
....................             rpm = F*60; 
06ED:  MOVF   46,W
06EE:  BSF    03.5
06EF:  MOVWF  2C
06F0:  BCF    03.5
06F1:  MOVF   45,W
06F2:  BSF    03.5
06F3:  MOVWF  2B
06F4:  CLRF   2E
06F5:  MOVLW  3C
06F6:  MOVWF  2D
*
070B:  BCF    03.5
070C:  CLRF   62
070D:  CLRF   61
070E:  MOVF   79,W
070F:  MOVWF  60
0710:  MOVF   78,W
0711:  MOVWF  5F
....................          }  // Fin del if anidado 
....................       Completado=0;           // Indico que ya han sido procesados los datos. 
0712:  BCF    3D.1
....................       }                       // Fin del if  
....................        
....................       if(rpm_Old!=0 && rpm!=0){rpm =(rpm+rpm_Old)/2;} // Saca el promedio 
0713:  MOVF   63,F
0714:  BTFSS  03.2
0715:  GOTO   71F
0716:  MOVF   64,F
0717:  BTFSS  03.2
0718:  GOTO   71F
0719:  MOVF   65,F
071A:  BTFSS  03.2
071B:  GOTO   71F
071C:  MOVF   66,F
071D:  BTFSC  03.2
071E:  GOTO   765
071F:  MOVF   5F,F
0720:  BTFSS  03.2
0721:  GOTO   72B
0722:  MOVF   60,F
0723:  BTFSS  03.2
0724:  GOTO   72B
0725:  MOVF   61,F
0726:  BTFSS  03.2
0727:  GOTO   72B
0728:  MOVF   62,F
0729:  BTFSC  03.2
072A:  GOTO   765
072B:  MOVF   63,W
072C:  ADDWF  5F,W
072D:  BSF    03.5
072E:  MOVWF  2B
072F:  BCF    03.5
0730:  MOVF   60,W
0731:  BSF    03.5
0732:  MOVWF  2C
0733:  BCF    03.5
0734:  MOVF   64,W
0735:  BTFSC  03.0
0736:  INCFSZ 64,W
0737:  GOTO   739
0738:  GOTO   73C
0739:  BSF    03.5
073A:  ADDWF  2C,F
073B:  BCF    03.5
073C:  MOVF   61,W
073D:  BSF    03.5
073E:  MOVWF  2D
073F:  BCF    03.5
0740:  MOVF   65,W
0741:  BTFSC  03.0
0742:  INCFSZ 65,W
0743:  GOTO   745
0744:  GOTO   748
0745:  BSF    03.5
0746:  ADDWF  2D,F
0747:  BCF    03.5
0748:  MOVF   62,W
0749:  BSF    03.5
074A:  MOVWF  2E
074B:  BCF    03.5
074C:  MOVF   66,W
074D:  BTFSC  03.0
074E:  INCFSZ 66,W
074F:  GOTO   751
0750:  GOTO   754
0751:  BSF    03.5
0752:  ADDWF  2E,F
0753:  BCF    03.5
0754:  BCF    03.0
0755:  BSF    03.5
0756:  RRF    2E,W
0757:  BCF    03.5
0758:  MOVWF  62
0759:  BSF    03.5
075A:  RRF    2D,W
075B:  BCF    03.5
075C:  MOVWF  61
075D:  BSF    03.5
075E:  RRF    2C,W
075F:  BCF    03.5
0760:  MOVWF  60
0761:  BSF    03.5
0762:  RRF    2B,W
0763:  BCF    03.5
0764:  MOVWF  5F
....................                                                        // de las rpm 
....................       if(rpm==0){rpm_Old=0;} 
0765:  MOVF   5F,F
0766:  BTFSS  03.2
0767:  GOTO   775
0768:  MOVF   60,F
0769:  BTFSS  03.2
076A:  GOTO   775
076B:  MOVF   61,F
076C:  BTFSS  03.2
076D:  GOTO   775
076E:  MOVF   62,F
076F:  BTFSS  03.2
0770:  GOTO   775
0771:  CLRF   66
0772:  CLRF   65
0773:  CLRF   64
0774:  CLRF   63
....................          rpm_Old=rpm; 
0775:  MOVF   62,W
0776:  MOVWF  66
0777:  MOVF   61,W
0778:  MOVWF  65
0779:  MOVF   60,W
077A:  MOVWF  64
077B:  MOVF   5F,W
077C:  MOVWF  63
....................           
....................       //drv_rpm_show(); 
.................... } 
077D:  RETURN
....................  
.................... void drv_rpm_show(void){ 
....................  
....................    //printf(lcd_putc, "\f%ldrpm",rpm); 
....................    printf(lcd_putc, "\f%ldrpm",F*60); 
*
0849:  MOVF   46,W
084A:  BSF    03.5
084B:  MOVWF  2C
084C:  BCF    03.5
084D:  MOVF   45,W
084E:  BSF    03.5
084F:  MOVWF  2B
0850:  CLRF   2E
0851:  MOVLW  3C
0852:  MOVWF  2D
*
0867:  MOVF   79,W
0868:  MOVWF  2C
0869:  MOVF   78,W
086A:  MOVWF  2B
086B:  MOVLW  0C
086C:  MOVWF  38
086D:  BCF    0A.3
086E:  BCF    03.5
086F:  CALL   1DF
0870:  BSF    0A.3
0871:  MOVLW  10
0872:  MOVWF  04
0873:  BSF    03.5
0874:  MOVF   2C,W
0875:  MOVWF  2E
0876:  MOVF   2B,W
0877:  MOVWF  2D
0878:  BCF    0A.3
0879:  BCF    03.5
087A:  CALL   220
087B:  BSF    0A.3
087C:  MOVLW  72
087D:  BSF    03.5
087E:  MOVWF  38
087F:  BCF    0A.3
0880:  BCF    03.5
0881:  CALL   1DF
0882:  BSF    0A.3
0883:  MOVLW  70
0884:  BSF    03.5
0885:  MOVWF  38
0886:  BCF    0A.3
0887:  BCF    03.5
0888:  CALL   1DF
0889:  BSF    0A.3
088A:  MOVLW  6D
088B:  BSF    03.5
088C:  MOVWF  38
088D:  BCF    0A.3
088E:  BCF    03.5
088F:  CALL   1DF
0890:  BSF    0A.3
*
1047:  MOVF   46,W
1048:  BSF    03.5
1049:  MOVWF  2C
104A:  BCF    03.5
104B:  MOVF   45,W
104C:  BSF    03.5
104D:  MOVWF  2B
104E:  CLRF   2E
104F:  MOVLW  3C
1050:  MOVWF  2D
*
1065:  MOVF   79,W
1066:  MOVWF  2C
1067:  MOVF   78,W
1068:  MOVWF  2B
1069:  MOVLW  0C
106A:  MOVWF  38
106B:  BCF    0A.4
106C:  BCF    03.5
106D:  CALL   1DF
106E:  BSF    0A.4
106F:  MOVLW  10
1070:  MOVWF  04
1071:  BSF    03.5
1072:  MOVF   2C,W
1073:  MOVWF  2E
1074:  MOVF   2B,W
1075:  MOVWF  2D
1076:  BCF    0A.4
1077:  BCF    03.5
1078:  CALL   220
1079:  BSF    0A.4
107A:  MOVLW  72
107B:  BSF    03.5
107C:  MOVWF  38
107D:  BCF    0A.4
107E:  BCF    03.5
107F:  CALL   1DF
1080:  BSF    0A.4
1081:  MOVLW  70
1082:  BSF    03.5
1083:  MOVWF  38
1084:  BCF    0A.4
1085:  BCF    03.5
1086:  CALL   1DF
1087:  BSF    0A.4
1088:  MOVLW  6D
1089:  BSF    03.5
108A:  MOVWF  38
108B:  BCF    0A.4
108C:  BCF    03.5
108D:  CALL   1DF
108E:  BSF    0A.4
....................    printf(lcd_putc, "\n%luhz ->%3.2fms",F,P_ms); 
*
0891:  MOVLW  0A
0892:  BSF    03.5
0893:  MOVWF  38
0894:  BCF    0A.3
0895:  BCF    03.5
0896:  CALL   1DF
0897:  BSF    0A.3
0898:  MOVLW  10
0899:  MOVWF  04
089A:  MOVF   46,W
089B:  BSF    03.5
089C:  MOVWF  2C
089D:  BCF    03.5
089E:  MOVF   45,W
089F:  BSF    03.5
08A0:  MOVWF  2B
08A1:  BCF    0A.3
08A2:  BCF    03.5
08A3:  CALL   2A4
08A4:  BSF    0A.3
08A5:  MOVLW  AD
08A6:  BSF    03.6
08A7:  MOVWF  0D
08A8:  MOVLW  00
08A9:  MOVWF  0F
08AA:  BCF    03.0
08AB:  MOVLW  05
08AC:  BSF    03.5
08AD:  BCF    03.6
08AE:  MOVWF  2B
08AF:  BCF    0A.3
08B0:  BCF    03.5
08B1:  CALL   30B
08B2:  BSF    0A.3
08B3:  MOVLW  02
08B4:  MOVWF  04
08B5:  MOVF   56,W
08B6:  BSF    03.5
08B7:  MOVWF  2E
08B8:  BCF    03.5
08B9:  MOVF   55,W
08BA:  BSF    03.5
08BB:  MOVWF  2D
08BC:  BCF    03.5
08BD:  MOVF   54,W
08BE:  BSF    03.5
08BF:  MOVWF  2C
08C0:  BCF    03.5
08C1:  MOVF   53,W
08C2:  BSF    03.5
08C3:  MOVWF  2B
08C4:  MOVLW  02
08C5:  MOVWF  2F
08C6:  BCF    0A.3
08C7:  BCF    03.5
08C8:  CALL   427
08C9:  BSF    0A.3
08CA:  MOVLW  6D
08CB:  BSF    03.5
08CC:  MOVWF  38
08CD:  BCF    0A.3
08CE:  BCF    03.5
08CF:  CALL   1DF
08D0:  BSF    0A.3
08D1:  MOVLW  73
08D2:  BSF    03.5
08D3:  MOVWF  38
08D4:  BCF    0A.3
08D5:  BCF    03.5
08D6:  CALL   1DF
08D7:  BSF    0A.3
*
108F:  MOVLW  0A
1090:  BSF    03.5
1091:  MOVWF  38
1092:  BCF    0A.4
1093:  BCF    03.5
1094:  CALL   1DF
1095:  BSF    0A.4
1096:  MOVLW  10
1097:  MOVWF  04
1098:  MOVF   46,W
1099:  BSF    03.5
109A:  MOVWF  2C
109B:  BCF    03.5
109C:  MOVF   45,W
109D:  BSF    03.5
109E:  MOVWF  2B
109F:  BCF    0A.4
10A0:  BCF    03.5
10A1:  CALL   2A4
10A2:  BSF    0A.4
10A3:  MOVLW  AD
10A4:  BSF    03.6
10A5:  MOVWF  0D
10A6:  MOVLW  00
10A7:  MOVWF  0F
10A8:  BCF    03.0
10A9:  MOVLW  05
10AA:  BSF    03.5
10AB:  BCF    03.6
10AC:  MOVWF  2B
10AD:  BCF    0A.4
10AE:  BCF    03.5
10AF:  CALL   30B
10B0:  BSF    0A.4
10B1:  MOVLW  02
10B2:  MOVWF  04
10B3:  MOVF   56,W
10B4:  BSF    03.5
10B5:  MOVWF  2E
10B6:  BCF    03.5
10B7:  MOVF   55,W
10B8:  BSF    03.5
10B9:  MOVWF  2D
10BA:  BCF    03.5
10BB:  MOVF   54,W
10BC:  BSF    03.5
10BD:  MOVWF  2C
10BE:  BCF    03.5
10BF:  MOVF   53,W
10C0:  BSF    03.5
10C1:  MOVWF  2B
10C2:  MOVLW  02
10C3:  MOVWF  2F
10C4:  BCF    0A.4
10C5:  BCF    03.5
10C6:  CALL   427
10C7:  BSF    0A.4
10C8:  MOVLW  6D
10C9:  BSF    03.5
10CA:  MOVWF  38
10CB:  BCF    0A.4
10CC:  BCF    03.5
10CD:  CALL   1DF
10CE:  BSF    0A.4
10CF:  MOVLW  73
10D0:  BSF    03.5
10D1:  MOVWF  38
10D2:  BCF    0A.4
10D3:  BCF    03.5
10D4:  CALL   1DF
10D5:  BSF    0A.4
10D6:  CLRF   27
10D7:  BTFSC  0B.7
10D8:  BSF    27.7
10D9:  BCF    0B.7
....................    //printf(lcd_putc, "\n%ldrpm -> %1.2fV",rpm,Vout); 
....................  } 
....................  
.................... int1 drv_gpio_alarmas(void){ 
....................  
....................    if (input(TEMP_ALARMA)==0 ){  
*
0A85:  BTFSC  06.1
0A86:  GOTO   2A3
0A87:  CLRF   27
0A88:  BTFSC  0B.7
0A89:  BSF    27.7
0A8A:  BCF    0B.7
....................       //AntiRebote1(TEMP_ALARMA); 
....................       delay_ms(200); 
0A8B:  MOVLW  C8
0A8C:  BSF    03.5
0A8D:  MOVWF  39
0A8E:  BCF    0A.3
0A8F:  BCF    03.5
0A90:  CALL   1CA
0A91:  BSF    0A.3
0A92:  BTFSC  27.7
0A93:  BSF    0B.7
....................       output_c(0b00000000); 
0A94:  CLRF   07
....................       printf(lcd_putc,"\fALARMA TEMP.\n"); 
0A95:  MOVLW  B4
0A96:  BSF    03.6
0A97:  MOVWF  0D
0A98:  MOVLW  00
0A99:  MOVWF  0F
0A9A:  BCF    0A.3
0A9B:  BCF    03.6
0A9C:  CALL   782
0A9D:  BSF    0A.3
....................       //delay_ms(2000); 
....................       Status_modo = MODO_INICIO; 
0A9E:  MOVLW  01
0A9F:  MOVWF  2C
....................       Flag_Alarmas = 1; 
0AA0:  BSF    2A.4
....................       Flag_Automatico = 0; 
0AA1:  BCF    2A.7
....................       Flag_Manual = 0; 
0AA2:  BCF    3D.0
....................    }   
....................        
....................    if (input(PRESION_ALARMA)==0){  
0AA3:  BTFSC  06.2
0AA4:  GOTO   2C1
0AA5:  CLRF   27
0AA6:  BTFSC  0B.7
0AA7:  BSF    27.7
0AA8:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................       delay_ms(200); 
0AA9:  MOVLW  C8
0AAA:  BSF    03.5
0AAB:  MOVWF  39
0AAC:  BCF    0A.3
0AAD:  BCF    03.5
0AAE:  CALL   1CA
0AAF:  BSF    0A.3
0AB0:  BTFSC  27.7
0AB1:  BSF    0B.7
....................       output_c(0b00000000); 
0AB2:  CLRF   07
....................       printf(lcd_putc,"\fALARMA PRESION\n"); 
0AB3:  MOVLW  BC
0AB4:  BSF    03.6
0AB5:  MOVWF  0D
0AB6:  MOVLW  00
0AB7:  MOVWF  0F
0AB8:  BCF    0A.3
0AB9:  BCF    03.6
0ABA:  CALL   782
0ABB:  BSF    0A.3
....................       Flag_Alarmas = 1; 
0ABC:  BSF    2A.4
....................       Status_modo = MODO_INICIO; 
0ABD:  MOVLW  01
0ABE:  MOVWF  2C
....................       Flag_Automatico = 0; 
0ABF:  BCF    2A.7
....................       Flag_Manual = 0; 
0AC0:  BCF    3D.0
....................       //delay_ms(2000); 
....................    }    
....................     
....................    if (input(P_EMERGENCIA)==0){  
0AC1:  BTFSC  06.6
0AC2:  GOTO   2E8
0AC3:  CLRF   27
0AC4:  BTFSC  0B.7
0AC5:  BSF    27.7
0AC6:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................        
....................       delay_ms(200); 
0AC7:  MOVLW  C8
0AC8:  BSF    03.5
0AC9:  MOVWF  39
0ACA:  BCF    0A.3
0ACB:  BCF    03.5
0ACC:  CALL   1CA
0ACD:  BSF    0A.3
0ACE:  BTFSC  27.7
0ACF:  BSF    0B.7
....................       output_c(0b00000000); 
0AD0:  CLRF   07
....................       printf(lcd_putc,"\f   PARADA  DE\n"); 
0AD1:  MOVLW  C5
0AD2:  BSF    03.6
0AD3:  MOVWF  0D
0AD4:  MOVLW  00
0AD5:  MOVWF  0F
0AD6:  BCF    0A.3
0AD7:  BCF    03.6
0AD8:  CALL   782
0AD9:  BSF    0A.3
....................       printf(lcd_putc,"   EMERGENCIA\n"); 
0ADA:  MOVLW  CD
0ADB:  BSF    03.6
0ADC:  MOVWF  0D
0ADD:  MOVLW  00
0ADE:  MOVWF  0F
0ADF:  BCF    0A.3
0AE0:  BCF    03.6
0AE1:  CALL   782
0AE2:  BSF    0A.3
....................       Flag_Alarmas = 1; 
0AE3:  BSF    2A.4
....................       Status_modo = MODO_INICIO; 
0AE4:  MOVLW  01
0AE5:  MOVWF  2C
....................       Flag_Automatico = 0; 
0AE6:  BCF    2A.7
....................       Flag_Manual = 0; 
0AE7:  BCF    3D.0
....................       //delay_ms(500); 
....................    } 
....................    
....................    if (input(STOP_RESET)==0){  
0AE8:  BTFSC  06.7
0AE9:  GOTO   305
0AEA:  CLRF   27
0AEB:  BTFSC  0B.7
0AEC:  BSF    27.7
0AED:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................       delay_ms(200); 
0AEE:  MOVLW  C8
0AEF:  BSF    03.5
0AF0:  MOVWF  39
0AF1:  BCF    0A.3
0AF2:  BCF    03.5
0AF3:  CALL   1CA
0AF4:  BSF    0A.3
0AF5:  BTFSC  27.7
0AF6:  BSF    0B.7
....................       output_c(0b00000000); 
0AF7:  CLRF   07
....................       printf(lcd_putc,"\f   STOP/FALLA\n"); 
0AF8:  MOVLW  D5
0AF9:  BSF    03.6
0AFA:  MOVWF  0D
0AFB:  MOVLW  00
0AFC:  MOVWF  0F
0AFD:  BCF    0A.3
0AFE:  BCF    03.6
0AFF:  CALL   782
0B00:  BSF    0A.3
....................       Flag_Alarmas = 1; 
0B01:  BSF    2A.4
....................       Status_modo = SIN_MODO; 
0B02:  CLRF   2C
....................       Flag_Automatico = 0; 
0B03:  BCF    2A.7
....................       Flag_Manual = 0; 
0B04:  BCF    3D.0
....................       //delay_ms(2000); 
....................    } 
....................    if(input(TEMP_ALARMA)== 1 && input(PRESION_ALARMA)== 1 && input(P_EMERGENCIA)==1 && input(STOP_RESET)==1){ 
0B05:  BTFSS  06.1
0B06:  GOTO   30E
0B07:  BTFSS  06.2
0B08:  GOTO   30E
0B09:  BTFSS  06.6
0B0A:  GOTO   30E
0B0B:  BTFSS  06.7
0B0C:  GOTO   30E
....................        Flag_Alarmas = 0; 
0B0D:  BCF    2A.4
....................    } 
....................  
....................    return Flag_Alarmas; 
0B0E:  MOVLW  00
0B0F:  BTFSC  2A.4
0B10:  MOVLW  01
0B11:  MOVWF  78
.................... } 
0B12:  RETURN
....................  
.................... void drv_gpio_modo(void){ 
*
00FD:  DATA 00,00
....................  
....................    if (input(F_AUTOMATICO)==0){  
*
0B13:  BTFSC  06.5
0B14:  GOTO   336
0B15:  CLRF   27
0B16:  BTFSC  0B.7
0B17:  BSF    27.7
0B18:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................       delay_ms(200); 
0B19:  MOVLW  C8
0B1A:  BSF    03.5
0B1B:  MOVWF  39
0B1C:  BCF    0A.3
0B1D:  BCF    03.5
0B1E:  CALL   1CA
0B1F:  BSF    0A.3
0B20:  BTFSC  27.7
0B21:  BSF    0B.7
....................       printf(lcd_putc,"\f FUNCIONAMIENTO\n"); 
0B22:  MOVLW  DD
0B23:  BSF    03.6
0B24:  MOVWF  0D
0B25:  MOVLW  00
0B26:  MOVWF  0F
0B27:  BCF    0A.3
0B28:  BCF    03.6
0B29:  CALL   782
0B2A:  BSF    0A.3
....................       printf(lcd_putc,"   AUTOMATICO\n"); 
0B2B:  MOVLW  E6
0B2C:  BSF    03.6
0B2D:  MOVWF  0D
0B2E:  MOVLW  00
0B2F:  MOVWF  0F
0B30:  BCF    0A.3
0B31:  BCF    03.6
0B32:  CALL   782
0B33:  BSF    0A.3
....................       Status_modo = MODO_INICIO; 
0B34:  MOVLW  01
0B35:  MOVWF  2C
....................       //Flag_Arranque = 1; 
....................    } 
....................     
....................    if (input(F_AUTOMATICO)==1){  
0B36:  BTFSS  06.5
0B37:  GOTO   359
0B38:  CLRF   27
0B39:  BTFSC  0B.7
0B3A:  BSF    27.7
0B3B:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................       delay_ms(200); 
0B3C:  MOVLW  C8
0B3D:  BSF    03.5
0B3E:  MOVWF  39
0B3F:  BCF    0A.3
0B40:  BCF    03.5
0B41:  CALL   1CA
0B42:  BSF    0A.3
0B43:  BTFSC  27.7
0B44:  BSF    0B.7
....................       printf(lcd_putc,"\f FUNCIONAMIENTO\n"); 
0B45:  MOVLW  EE
0B46:  BSF    03.6
0B47:  MOVWF  0D
0B48:  MOVLW  00
0B49:  MOVWF  0F
0B4A:  BCF    0A.3
0B4B:  BCF    03.6
0B4C:  CALL   782
0B4D:  BSF    0A.3
....................       printf(lcd_putc,"     MANUAL\n"); 
0B4E:  MOVLW  F7
0B4F:  BSF    03.6
0B50:  MOVWF  0D
0B51:  MOVLW  00
0B52:  MOVWF  0F
0B53:  BCF    0A.3
0B54:  BCF    03.6
0B55:  CALL   782
0B56:  BSF    0A.3
....................       Status_modo = MODO_INICIO; 
0B57:  MOVLW  01
0B58:  MOVWF  2C
....................       //Flag_Arranque = 1; 
....................    } 
.................... } 
0B59:  RETURN
....................  
....................  
.................... void drv_gpio_arranque(void){ 
....................  
....................    if (input(A_AUTOMATICO)==0 && input(A_MANUAL)==1){  
0B5A:  BTFSC  06.4
0B5B:  GOTO   36F
0B5C:  BTFSS  06.3
0B5D:  GOTO   36F
0B5E:  CLRF   27
0B5F:  BTFSC  0B.7
0B60:  BSF    27.7
0B61:  BCF    0B.7
....................       //AntiRebote1(PRESION_ALARMA ); 
....................       delay_ms(200); 
0B62:  MOVLW  C8
0B63:  BSF    03.5
0B64:  MOVWF  39
0B65:  BCF    0A.3
0B66:  BCF    03.5
0B67:  CALL   1CA
0B68:  BSF    0A.3
0B69:  BTFSC  27.7
0B6A:  BSF    0B.7
....................       Status_modo = MODO_ARRANQUE; 
0B6B:  MOVLW  02
0B6C:  MOVWF  2C
....................       Select = 0; 
0B6D:  CLRF   32
....................       Flag_Alarmas = 0; 
0B6E:  BCF    2A.4
....................    } 
....................     
....................  
.................... } 
0B6F:  BSF    0A.3
0B70:  BCF    0A.4
0B71:  GOTO   45A (RETURN)
....................  
.................... void drv_gpio_arranque_P_on(void){ 
....................    output_bit(ARRANQUE_ENCENDIDO,1); 
*
0BDF:  BSF    07.0
.................... } 
....................  
.................... void drv_gpio_arranque_P_off(void){ 
....................    output_bit(ARRANQUE_ENCENDIDO,0); 
*
0BDC:  BCF    07.0
.................... } 
....................  
.................... void drv_gpio_arranque_A_on(void){ 
....................    output_bit(E_ALTERNADOR,1); 
0BDD:  BSF    07.2
.................... } 
....................  
.................... void drv_gpio_arranque_A_off(void){ 
....................    output_bit(E_ALTERNADOR,0); 
.................... } 
....................  
.................... void drv_gpio_solenoide_on(void){ 
....................    output_bit(SOLENOIDE,1); 
*
0BCF:  BSF    07.1
.................... } 
....................  
.................... void drv_gpio_solenoide_off(void){ 
....................    output_bit(SOLENOIDE,0); 
.................... } 
....................  
.................... void drv_gpio_transfer_on(void){ 
....................    output_bit(TRANSFER,1); 
*
0B79:  BSF    07.4
.................... }  
....................  
.................... void drv_gpio_transfer_off(void){ 
....................    output_bit(TRANSFER,0); 
.................... } 
....................  
.................... void drv_gpio_generador_activo(void){ 
....................  
....................    Vch1 = drv_gpio_adc_read(2); 
*
0BC1:  MOVLW  02
0BC2:  MOVWF  68
0BC3:  CALL   382
0BC4:  MOVF   79,W
0BC5:  MOVWF  3A
0BC6:  MOVF   78,W
0BC7:  MOVWF  39
....................    Vch2 = drv_gpio_adc_read(3); 
0BC8:  MOVLW  03
0BC9:  MOVWF  68
0BCA:  CALL   382
0BCB:  MOVF   79,W
0BCC:  MOVWF  3C
0BCD:  MOVF   78,W
0BCE:  MOVWF  3B
....................    drv_gpio_solenoide_on();  // Solenoide On Intento de arranque 
....................     
....................     
....................   
....................    if(Vch1 > 0 || Vch2 > 0){ 
*
0BD0:  MOVF   39,F
0BD1:  BTFSS  03.2
0BD2:  GOTO   3DC
0BD3:  MOVF   3A,F
0BD4:  BTFSS  03.2
0BD5:  GOTO   3DC
0BD6:  MOVF   3B,F
0BD7:  BTFSS  03.2
0BD8:  GOTO   3DC
0BD9:  MOVF   3C,F
0BDA:  BTFSC  03.2
0BDB:  GOTO   3DF
....................     
....................       drv_gpio_arranque_P_off(); // Arranque para encendido off. se apaga cuando  
....................                                  // se cta generacionde voltaje en el generador 
....................       drv_gpio_arranque_A_on();  // Exitacion alternador ON. se activa cuando la  
....................                                  // planta electrica ha entrado en funcionamiento 
....................    } 
....................     
....................    else{ 
*
0BDE:  GOTO   3E0
....................        
....................       drv_gpio_arranque_P_on(); // Arranque para encendido ON 
....................      
....................    } 
....................     
.................... } 
*
0BE0:  BSF    0A.3
0BE1:  BCF    0A.4
0BE2:  GOTO   46E (RETURN)
....................  
.................... void drv_activar_transfer(void){ 
....................  
....................    if(transfer_on > 240){ 
*
0B72:  MOVF   34,F
0B73:  BTFSS  03.2
0B74:  GOTO   379
0B75:  MOVF   33,W
0B76:  SUBLW  F0
0B77:  BTFSC  03.0
0B78:  GOTO   37C
....................       drv_gpio_transfer_on(); 
....................       transfer_on = 0; 
*
0B7A:  CLRF   34
0B7B:  CLRF   33
....................    } 
....................    
....................    transfer_on++; 
0B7C:  INCF   33,F
0B7D:  BTFSC  03.2
0B7E:  INCF   34,F
....................  
.................... } 
0B7F:  BSF    0A.3
0B80:  BCF    0A.4
0B81:  GOTO   46D (RETURN)
....................  
....................  
....................  
....................    #include <drv_esp8266.h> 
.................... #include <stdint.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                           stdint.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard integer definitions.                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDINT 
....................  
.................... #define _STDINT 
....................  
.................... //////////// exact width 
....................  
.................... typedef signed int8 int8_t; 
.................... typedef unsigned int8 uint8_t; 
.................... typedef signed int16 int16_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int32 int32_t; 
.................... typedef unsigned int32 uint32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int24_t; 
.................... //typedef unsigned int24 uint24_t; 
.................... typedef signed int64 int64_t; 
.................... typedef unsigned int64 uint64_t; 
.................... #endif 
....................  
.................... #define INT8_MAX  (128) 
.................... #define INT8_MIN  (-127) 
.................... #define UINT8_MAX (255) 
....................  
.................... #define INT16_MAX  (32767) 
.................... #define INT16_MIN  (-32768) 
.................... #define UINT16_MAX (65535) 
....................  
.................... #define INT32_MAX  (2147483647) 
.................... #define INT32_MIN  (-2147483648) 
.................... #define UINT32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT24_MAX  (8388607) 
.................... //#define INT24_MIN  (-8388608) 
.................... //#define UINT24_MAX (16777215) 
....................  
.................... #define INT64_MAX  (9223372036854775807) 
.................... #define INT64_MIN  (-9223372036854775808) 
.................... #define UINT64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// minimum width 
....................  
.................... typedef signed int8 int_least8_t; 
.................... typedef unsigned int8 uint_least8_t; 
.................... typedef signed int16 int_least16_t; 
.................... typedef unsigned int16 uint_least16_t; 
.................... typedef signed int32 int_least32_t; 
.................... typedef unsigned int32 uint_least32_t; 
....................  
.................... #if defined(__PCD__) 
.................... //typedef signed int24 int_least24_t; 
.................... //typedef unsigned int24 uint_least24_t; 
.................... typedef signed int64 int_least64_t; 
.................... typedef unsigned int64 uint_least64_t; 
.................... #endif 
....................  
.................... #define INT_LEAST8_MAX  (128) 
.................... #define INT_LEAST8_MIN  (-127) 
.................... #define UINT_LEAST8_MAX (255) 
....................  
.................... #define INT_LEAST16_MAX  (32767) 
.................... #define INT_LEAST16_MIN  (-32768) 
.................... #define UINT_LEAST16_MAX (65535) 
....................  
.................... #define INT_LEAST32_MAX  (2147483647) 
.................... #define INT_LEAST32_MIN  (-2147483648) 
.................... #define UINT_LEAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_LEAST24_MAX  (8388607) 
.................... //#define INT_LEAST24_MIN  (-8388608) 
.................... //#define UINT_LEAST24_MAX (16777215) 
....................  
.................... #define INT_LEAST64_MAX  (9223372036854775807) 
.................... #define INT_LEAST64_MIN  (-9223372036854775808) 
.................... #define UINT_LEAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... ///////// fastest width 
....................  
.................... #if defined(__PCD__) 
.................... typedef signed int16 int_fast8_t; 
.................... typedef unsigned int16 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (32767) 
.................... #define INT_FAST8_MIN  (-32768) 
.................... #define UINT_FAST8_MAX (65535) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... //typedef signed int24 int_fast24_t; 
.................... //typedef unsigned int24 uint_fast24_t; 
.................... typedef signed int64 int_fast64_t; 
.................... typedef unsigned int64 uint_fast64_t; 
.................... #else 
.................... typedef signed int8 int_fast8_t; 
.................... typedef unsigned int8 uint_fast8_t; 
.................... #define INT_FAST8_MAX  (128) 
.................... #define INT_FAST8_MIN  (-127) 
.................... #define UINT_FAST8_MAX (255) 
.................... typedef signed int16 int_fast16_t; 
.................... typedef unsigned int16 uint_fast16_t; 
.................... #endif 
....................  
.................... typedef signed int32 int_fast32_t; 
.................... typedef unsigned int32 uint_fast32_t; 
....................  
.................... #define INT_FAST16_MAX  (32767) 
.................... #define INT_FAST16_MIN  (-32768) 
.................... #define UINT_FAST16_MAX (65535) 
....................  
.................... #define INT_FAST32_MAX  (2147483647) 
.................... #define INT_FAST32_MIN  (-2147483648) 
.................... #define UINT_FAST32_MAX (4294967295) 
....................  
.................... #if defined(__PCD__) 
.................... //#define INT_FAST24_MAX  (8388607) 
.................... //#define INT_FAST24_MIN  (-8388608) 
.................... //#define UINT_FAST24_MAX (16777215) 
....................  
.................... #define INT_FAST64_MAX  (9223372036854775807) 
.................... #define INT_FAST64_MIN  (-9223372036854775808) 
.................... #define UINT_FAST64_MAX (18446744073709551615) 
.................... #endif 
....................  
.................... //////////// big enough to hold pointers (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intptr_t uintptr_t 
....................  
.................... /// INTPTRN_MIN INTPTRN_MAX UINTPTRN_MAX 
....................  
....................  
.................... /////////// greatest width (OPTIONAL) 
....................  
.................... /// TODO 
....................  
.................... /// intmax_t uintmax_t 
....................  
.................... /// INTMAXN_MIN INTMAXN_MAX UINTMAXN_MAX 
....................  
.................... /// INTMAX_C(value) UINTMAX_C(value) 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #ifndef __DRV_ESP8266_H 
.................... #define __DRV_ESP8266_H 
....................  
.................... /** Some constants **/ 
....................  
....................  
.................... #define ESP8266_STATION 0x01 
....................  
.................... #define ESP8266_SOFTAP 0x02 
....................  
....................    #define ESP8266_TCP 1 
....................    #define ESP8266_UDP 0 
....................  
....................    #define ESP8266_OK         1 
....................    #define ESP8266_READY      2 
....................  
....................    #define ESP8266_FAIL       3 
....................    #define ESP8266_NOCHANGE   4 
....................  
....................    #define ESP8266_LINKED     5 
....................  
....................    #define ESP8266_UNLINK     6 
....................     
....................    //commands 
....................    #define ATE0               "ATE0\r\n"           // SIN ECO 
....................    #define AT_CWMODE2         "AT+CWMODE=2\r\n"    // ACTUA COMO  ROUTER CREA UNA RED PROPIA 
....................    #define AT_CIPSERVER0      "AT+CIPSERVER=0\r\n" // Cierra sevidores 
....................    #define AT_CIPMUX0         "AT+CIPMUX=0\r\n"    // Conexion un unica 
....................     
....................    #define AT_CIPMODE0        "AT+CIPMODE=0\r\n"   //Trabaja en modo normal 
....................     
....................    //Red WIFI como acces point  cana 5  clave tipo WPA2_PSK 
....................    #define AT_CWSAP           "AT+CWSAP=\"ESP8266_ARZ\",\"noconectar\",5,3\r\n" 
....................    //Coloca la IP del acces ponit 
....................    #define AT_CIPSERVER0      "AT+CIPAP=\"192.168.1.254\"\r\n" 
....................    //Crea el servidor y el puerto a escuchar 
....................    #define AT_CIPMUX1         "AT+CIPMUX=1\r\n" //habilita multiples conexiones 
....................    //Activa la escucha por el puerto 200 
....................    #define AT_CIPSERVER      "AT+CIPSERVER=1,200\r\n" 
....................     
....................    //tiemo en el cual actua como servidor en segundos    
....................    #define AT_CIPSTO0   "AT+CIPSTO=0\r\n" // siempre activo 
....................     
....................    void drv_esp8266_init(void); 
....................     
.................... #endif /* __DRV_LCD_H */ 
....................  
....................    #include <drv_esp8266.c> 
.................... #include "system.h" 
.................... #ifndef __SYSTEM_H 
.................... #define __SYSTEM_H 
....................  
....................    #include <16f877a.h> 
....................    #Device adc=10 
....................    #use delay(clock=4000000) 
....................    #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,NODEBUG,BROWNOUT,NOCPD,NOWRT 
....................    #use RS232(BAUD=9600, BITS=8, PARITY=N, XMIT=PIN_C6, RCV=PIN_C7) 
....................    //#use fast_io(a) 
....................    #use fast_io(b) 
....................    #use fast_io(c) 
....................    #use fast_io(d) 
....................    //#use fast_io(e) 
....................     
....................    //#define Boton1 pin_b7 
....................     
....................     
....................    #include <LCD.c> 
....................    #include <mensajes.h> 
....................    #include <mensajes.c> 
....................     
....................    #include <drv_lcd.h> 
....................    #include <drv_lcd.c> 
....................    #include <drv_gpio.h> 
....................    #include <drv_gpio.c>  
....................    #include <drv_esp8266.h> 
....................    #include <drv_esp8266.c> 
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
....................  
.................... void drv_esp8266_init(void){ 
....................  
....................    Printf(ATE0);           // SIN ECO 
*
09B2:  MOVLW  FE
09B3:  BSF    03.6
09B4:  MOVWF  0D
09B5:  MOVLW  00
09B6:  MOVWF  0F
09B7:  BCF    03.6
09B8:  CALL   16A
....................    delay_ms(2000); 
09B9:  MOVLW  08
09BA:  MOVWF  67
09BB:  CLRF   27
09BC:  BTFSC  0B.7
09BD:  BSF    27.7
09BE:  BCF    0B.7
09BF:  MOVLW  FA
09C0:  BSF    03.5
09C1:  MOVWF  39
09C2:  BCF    0A.3
09C3:  BCF    03.5
09C4:  CALL   1CA
09C5:  BSF    0A.3
09C6:  BTFSC  27.7
09C7:  BSF    0B.7
09C8:  DECFSZ 67,F
09C9:  GOTO   1BB
....................     
....................    Printf(AT_CWMODE2);     // ACTUA COMO  ROUTER CREA UNA RED PROPIA 
09CA:  MOVLW  02
09CB:  BSF    03.6
09CC:  MOVWF  0D
09CD:  MOVLW  01
09CE:  MOVWF  0F
09CF:  BCF    03.6
09D0:  CALL   16A
09D1:  CLRF   27
09D2:  BTFSC  0B.7
09D3:  BSF    27.7
09D4:  BCF    0B.7
....................    delay_ms(200); 
09D5:  MOVLW  C8
09D6:  BSF    03.5
09D7:  MOVWF  39
09D8:  BCF    0A.3
09D9:  BCF    03.5
09DA:  CALL   1CA
09DB:  BSF    0A.3
09DC:  BTFSC  27.7
09DD:  BSF    0B.7
....................     
....................    Printf(AT_CIPSERVER0);  // Cierra sevidores 
09DE:  MOVLW  09
09DF:  BSF    03.6
09E0:  MOVWF  0D
09E1:  MOVLW  01
09E2:  MOVWF  0F
09E3:  BCF    03.6
09E4:  CALL   16A
09E5:  CLRF   27
09E6:  BTFSC  0B.7
09E7:  BSF    27.7
09E8:  BCF    0B.7
....................    delay_ms(200); 
09E9:  MOVLW  C8
09EA:  BSF    03.5
09EB:  MOVWF  39
09EC:  BCF    0A.3
09ED:  BCF    03.5
09EE:  CALL   1CA
09EF:  BSF    0A.3
09F0:  BTFSC  27.7
09F1:  BSF    0B.7
....................     
....................    Printf(AT_CIPMUX0);     // Conexion un unica 
09F2:  MOVLW  17
09F3:  BSF    03.6
09F4:  MOVWF  0D
09F5:  MOVLW  01
09F6:  MOVWF  0F
09F7:  BCF    03.6
09F8:  CALL   16A
09F9:  CLRF   27
09FA:  BTFSC  0B.7
09FB:  BSF    27.7
09FC:  BCF    0B.7
....................    delay_ms(200); 
09FD:  MOVLW  C8
09FE:  BSF    03.5
09FF:  MOVWF  39
0A00:  BCF    0A.3
0A01:  BCF    03.5
0A02:  CALL   1CA
0A03:  BSF    0A.3
0A04:  BTFSC  27.7
0A05:  BSF    0B.7
....................     
....................    Printf(AT_CIPMODE0);    //Trabaja en modo normal 
0A06:  MOVLW  1E
0A07:  BSF    03.6
0A08:  MOVWF  0D
0A09:  MOVLW  01
0A0A:  MOVWF  0F
0A0B:  BCF    03.6
0A0C:  CALL   16A
0A0D:  CLRF   27
0A0E:  BTFSC  0B.7
0A0F:  BSF    27.7
0A10:  BCF    0B.7
....................    delay_ms(200); 
0A11:  MOVLW  C8
0A12:  BSF    03.5
0A13:  MOVWF  39
0A14:  BCF    0A.3
0A15:  BCF    03.5
0A16:  CALL   1CA
0A17:  BSF    0A.3
0A18:  BTFSC  27.7
0A19:  BSF    0B.7
....................     
....................    //Red WIFI como acces point  cana 5  clave tipo WPA2_PSK 
....................    Printf(AT_CWSAP); 
0A1A:  MOVLW  26
0A1B:  BSF    03.6
0A1C:  MOVWF  0D
0A1D:  MOVLW  01
0A1E:  MOVWF  0F
0A1F:  BCF    03.6
0A20:  CALL   16A
....................    delay_ms(600); 
0A21:  MOVLW  03
0A22:  MOVWF  67
0A23:  CLRF   27
0A24:  BTFSC  0B.7
0A25:  BSF    27.7
0A26:  BCF    0B.7
0A27:  MOVLW  C8
0A28:  BSF    03.5
0A29:  MOVWF  39
0A2A:  BCF    0A.3
0A2B:  BCF    03.5
0A2C:  CALL   1CA
0A2D:  BSF    0A.3
0A2E:  BTFSC  27.7
0A2F:  BSF    0B.7
0A30:  DECFSZ 67,F
0A31:  GOTO   223
....................     
....................    //Coloca la IP del acces ponit 
....................    Printf(AT_CIPSERVER0); 
0A32:  MOVLW  3B
0A33:  BSF    03.6
0A34:  MOVWF  0D
0A35:  MOVLW  01
0A36:  MOVWF  0F
0A37:  BCF    03.6
0A38:  CALL   16A
0A39:  CLRF   27
0A3A:  BTFSC  0B.7
0A3B:  BSF    27.7
0A3C:  BCF    0B.7
....................    delay_ms(200); 
0A3D:  MOVLW  C8
0A3E:  BSF    03.5
0A3F:  MOVWF  39
0A40:  BCF    0A.3
0A41:  BCF    03.5
0A42:  CALL   1CA
0A43:  BSF    0A.3
0A44:  BTFSC  27.7
0A45:  BSF    0B.7
....................     
....................    //Crea el servidor y el puerto a escuchar 
....................    Printf(AT_CIPMUX1);  //Habilita multiples conexiones 
0A46:  MOVLW  49
0A47:  BSF    03.6
0A48:  MOVWF  0D
0A49:  MOVLW  01
0A4A:  MOVWF  0F
0A4B:  BCF    03.6
0A4C:  CALL   16A
0A4D:  CLRF   27
0A4E:  BTFSC  0B.7
0A4F:  BSF    27.7
0A50:  BCF    0B.7
....................    delay_ms(200); 
0A51:  MOVLW  C8
0A52:  BSF    03.5
0A53:  MOVWF  39
0A54:  BCF    0A.3
0A55:  BCF    03.5
0A56:  CALL   1CA
0A57:  BSF    0A.3
0A58:  BTFSC  27.7
0A59:  BSF    0B.7
....................     
....................    //Activa la escucha por el puerto 200 
....................    Printf(AT_CIPSERVER); 
0A5A:  MOVLW  50
0A5B:  BSF    03.6
0A5C:  MOVWF  0D
0A5D:  MOVLW  01
0A5E:  MOVWF  0F
0A5F:  BCF    03.6
0A60:  CALL   16A
0A61:  CLRF   27
0A62:  BTFSC  0B.7
0A63:  BSF    27.7
0A64:  BCF    0B.7
....................    delay_ms(200); 
0A65:  MOVLW  C8
0A66:  BSF    03.5
0A67:  MOVWF  39
0A68:  BCF    0A.3
0A69:  BCF    03.5
0A6A:  CALL   1CA
0A6B:  BSF    0A.3
0A6C:  BTFSC  27.7
0A6D:  BSF    0B.7
....................     
....................    //tiemo en el cual actua como servidor en segundos  
....................    Printf(AT_CIPSTO0); // siempre activo 
0A6E:  MOVLW  5B
0A6F:  BSF    03.6
0A70:  MOVWF  0D
0A71:  MOVLW  01
0A72:  MOVWF  0F
0A73:  BCF    03.6
0A74:  CALL   16A
0A75:  CLRF   27
0A76:  BTFSC  0B.7
0A77:  BSF    27.7
0A78:  BCF    0B.7
....................    delay_ms(200); 
0A79:  MOVLW  C8
0A7A:  BSF    03.5
0A7B:  MOVWF  39
0A7C:  BCF    0A.3
0A7D:  BCF    03.5
0A7E:  CALL   1CA
0A7F:  BSF    0A.3
0A80:  BTFSC  27.7
0A81:  BSF    0B.7
....................     
.................... } 
0A82:  BSF    0A.3
0A83:  BCF    0A.4
0A84:  GOTO   42A (RETURN)
....................  
....................    //#include <drv_rpm.h> 
....................    //#include <drv_rpm.c> 
....................    #include <system.c> 
....................  
.................... #endif 
....................  
....................  
....................  
.................... int1 timetm1 = 0; 
.................... void drv_start(); 
.................... void main_config(); 
....................  
.................... //INTERRUPCIONES 
.................... /* 
.................... #int_rb 
.................... Void Rb4_Rb7_ISR(){ 
....................    //drv_rpm_int_rb(); 
.................... } 
....................  */ 
.................... /*Interrupcion por RB4-RB7*/ 
.................... #int_ext 
.................... void RB0_ISR(){ 
....................  
....................    if (Select == 0 && Flag_Alarmas==0 && Status_modo == MODO_ARRANQUE){ 
*
0800:  MOVF   32,F
0801:  BTFSS  03.2
0802:  GOTO   0DB
0803:  BTFSC  2A.4
0804:  GOTO   0DB
0805:  MOVF   2C,W
0806:  SUBLW  02
0807:  BTFSS  03.2
0808:  GOTO   0DB
....................      drv_rpm_int_ext(); 
....................      drv_rpm_capture(); 
*
08D8:  BCF    0A.3
08D9:  CALL   609
08DA:  BSF    0A.3
....................    } 
....................  } 
....................  
.................... /*Interrupcion por timer1*/ 
....................  
08DB:  BCF    0B.1
08DC:  BCF    0A.3
08DD:  BCF    0A.4
08DE:  GOTO   021
.................... #int_timer1 
.................... void timer1_isr(void) 
.................... { 
....................  
.................... //drv_gpio_ticks(); 
.................... /* 
....................    if(timetm1==1){    
....................       drv_gpio_ticks(); 
....................    }        
....................    timetm1++;  
.................... */ 
....................  
.................... } 
....................  
....................  
*
077E:  BCF    0C.0
077F:  BCF    0A.3
0780:  BCF    0A.4
0781:  GOTO   021
.................... void main(){ 
*
0BF3:  CLRF   04
0BF4:  BCF    03.7
0BF5:  MOVLW  1F
0BF6:  ANDWF  03,F
0BF7:  MOVLW  19
0BF8:  BSF    03.5
0BF9:  MOVWF  19
0BFA:  MOVLW  A6
0BFB:  MOVWF  18
0BFC:  MOVLW  90
0BFD:  BCF    03.5
0BFE:  MOVWF  18
0BFF:  CLRF   32
0C00:  CLRF   34
0C01:  CLRF   33
0C02:  BCF    2A.7
0C03:  BCF    3D.0
0C04:  BCF    3D.3
0C05:  BSF    03.5
0C06:  BSF    1F.0
0C07:  BSF    1F.1
0C08:  BSF    1F.2
0C09:  BCF    1F.3
0C0A:  MOVLW  07
0C0B:  MOVWF  1C
....................     
....................    main_config(); // Configuracion inicial 
*
0C0F:  GOTO   0DF
....................    delay_us(50); 
0C10:  MOVLW  10
0C11:  MOVWF  77
0C12:  DECFSZ 77,F
0C13:  GOTO   412
0C14:  NOP
....................    drv_lcd_show(); 
0C15:  BCF    0A.3
0C16:  GOTO   7D8
0C17:  BSF    0A.3
....................    delay_ms(1000); 
0C18:  MOVLW  04
0C19:  MOVWF  67
0C1A:  CLRF   27
0C1B:  BTFSC  0B.7
0C1C:  BSF    27.7
0C1D:  BCF    0B.7
0C1E:  MOVLW  FA
0C1F:  BSF    03.5
0C20:  MOVWF  39
0C21:  BCF    0A.3
0C22:  BCF    03.5
0C23:  CALL   1CA
0C24:  BSF    0A.3
0C25:  BTFSC  27.7
0C26:  BSF    0B.7
0C27:  DECFSZ 67,F
0C28:  GOTO   41A
....................    drv_esp8266_init(); 
0C29:  GOTO   1B2
....................    //drv_gpio_adc_lcd(); 
....................    //Status_modo = MODO_INICIO; 
....................  
....................    while(1){ 
....................        
....................       // drv_rpm_capture();  
....................       switch(Status_modo){ 
0C2A:  MOVF   2C,W
0C2B:  BTFSC  03.2
0C2C:  GOTO   434
0C2D:  XORLW  01
0C2E:  BTFSC  03.2
0C2F:  GOTO   447
0C30:  XORLW  03
0C31:  BTFSC  03.2
0C32:  GOTO   45B
0C33:  GOTO   477
....................        
....................          case SIN_MODO: 
....................             if(drv_gpio_alarmas()==0){ 
0C34:  CALL   285
0C35:  MOVF   78,F
0C36:  BTFSS  03.2
0C37:  GOTO   446
....................                drv_gpio_modo(); 
0C38:  CALL   313
0C39:  CLRF   27
0C3A:  BTFSC  0B.7
0C3B:  BSF    27.7
0C3C:  BCF    0B.7
....................                delay_ms(100); 
0C3D:  MOVLW  64
0C3E:  BSF    03.5
0C3F:  MOVWF  39
0C40:  BCF    0A.3
0C41:  BCF    03.5
0C42:  CALL   1CA
0C43:  BSF    0A.3
0C44:  BTFSC  27.7
0C45:  BSF    0B.7
....................             } 
....................             break; 
0C46:  GOTO   477
....................              
....................          case MODO_INICIO: 
....................             if(drv_gpio_alarmas()==0){ 
0C47:  CALL   285
0C48:  MOVF   78,F
0C49:  BTFSS  03.2
0C4A:  GOTO   45A
0C4B:  CLRF   27
0C4C:  BTFSC  0B.7
0C4D:  BSF    27.7
0C4E:  BCF    0B.7
....................                delay_ms(100); 
0C4F:  MOVLW  64
0C50:  BSF    03.5
0C51:  MOVWF  39
0C52:  BCF    0A.3
0C53:  BCF    03.5
0C54:  CALL   1CA
0C55:  BSF    0A.3
0C56:  BTFSC  27.7
0C57:  BSF    0B.7
....................                drv_gpio_modo(); 
0C58:  CALL   313
....................                drv_gpio_arranque(); 
0C59:  GOTO   35A
....................                 
....................             } 
....................             break; 
0C5A:  GOTO   477
....................                  
....................          case MODO_ARRANQUE: 
....................             if(drv_gpio_alarmas()==0){ 
0C5B:  CALL   285
0C5C:  MOVF   78,F
0C5D:  BTFSS  03.2
0C5E:  GOTO   476
0C5F:  CLRF   27
0C60:  BTFSC  0B.7
0C61:  BSF    27.7
0C62:  BCF    0B.7
....................                delay_ms(100); 
0C63:  MOVLW  64
0C64:  BSF    03.5
0C65:  MOVWF  39
0C66:  BCF    0A.3
0C67:  BCF    03.5
0C68:  CALL   1CA
0C69:  BSF    0A.3
0C6A:  BTFSC  27.7
0C6B:  BSF    0B.7
....................                drv_activar_transfer(); 
0C6C:  GOTO   372
....................                drv_gpio_generador_activo(); 
0C6D:  GOTO   3C1
....................                drv_gpio_adc_select(); 
0C6E:  GOTO   3E3
....................                drv_gpio_adc_show(Select);     
0C6F:  MOVF   32,W
0C70:  MOVWF  67
0C71:  BSF    0A.4
0C72:  BCF    0A.3
0C73:  GOTO   000
0C74:  BCF    0A.4
0C75:  BSF    0A.3
....................                 
....................             } 
....................             break;            
0C76:  GOTO   477
....................       } 
....................    }  
0C77:  GOTO   42A
.................... } 
....................  
.................... void main_config(){ 
....................  
0C78:  SLEEP
....................    set_tris_d(0b00000000);   // Manejo de pantalla LCD 
*
08DF:  MOVLW  00
08E0:  BSF    03.5
08E1:  MOVWF  08
....................    set_tris_c(0b00100000);   // Manejo de Salidas Digitales 
08E2:  MOVLW  20
08E3:  MOVWF  07
....................    set_tris_b(0b11111111);   // Entradas Digitales 
08E4:  MOVLW  FF
08E5:  MOVWF  06
....................    //set_tris_e(0b00000010);   // Entrada para Cambiar lo que se muestra en Pantalla 
....................     
....................    enable_interrupts(int_ext);      // Habilito las interrupcio por RB0 
08E6:  BCF    03.5
08E7:  BSF    0B.4
....................    //enable_interrupts(int_rb);       // Habilito innterrupcion RB4 - RB7 
....................    enable_interrupts(int_timer1);   // Habilito la interrupcion por timer1 
08E8:  BSF    03.5
08E9:  BSF    0C.0
....................    enable_interrupts(global);       // Habilitacion Global de interruociones 
08EA:  MOVLW  C0
08EB:  BCF    03.5
08EC:  IORWF  0B,F
....................     
....................    //ext_int_edge(0,H_TO_L);          // Config. Ext RB0  por flanco de subida 
....................    ext_int_edge(0,L_TO_H);          // Config. Ext RB0  por flanco de subida 
08ED:  BSF    03.5
08EE:  BSF    01.6
....................    setup_timer_0(rtcc_ext_h_to_l | rtcc_div_2); /* Configuracion del timer 0 
08EF:  MOVF   01,W
08F0:  ANDLW  C0
08F1:  IORLW  30
08F2:  MOVWF  01
....................                                              como contador para detectar por 
....................                                              flanco de bajada con un  
....................                                              preescaler de 2 (Cuenta cada 
....................                                              2us)*/ 
....................    //setup_timer_1(t1_internal | t1_div_by_8);  
....................    /* configuracion del timer 1 como            
....................    Temporizador con un preescalerde 8 (cuenta cada 8us)*/ 
....................                                               
....................    //setup_timer_1(t1_internal | t1_div_by_1);   
....................    setup_timer_1(t1_internal | t1_div_by_8); /* configuracion del timer 1 como 
08F3:  MOVLW  B5
08F4:  BCF    03.5
08F5:  MOVWF  10
....................                                              Temporizador con un preescaler 
....................                                              de 8 (cuenta cada 8us)*/ 
....................    // Duty minimo = 5(1%), Duty Max = 500(100%)   
....................    //Preescaler Timer 2 = 4 
....................    //Frecuencia PWM 2000HZ 
....................    setup_timer_2(T2_DIV_BY_4, 124, 1); 
08F6:  MOVLW  00
08F7:  MOVWF  78
08F8:  IORLW  05
08F9:  MOVWF  12
08FA:  MOVLW  7C
08FB:  BSF    03.5
08FC:  MOVWF  12
....................    //setup_ccp1(CCP_PWM);                // Inicializacion del modulo PWM 
....................     
....................    set_timer0(0);    //inicializacion del timer 0 
08FD:  BCF    03.5
08FE:  CLRF   01
....................    //set_pwm1_duty(5); 
....................     
....................    lcd_init(); // Inicializacion de pantalla LCD 
....................     
....................    //output_b(0b00000000); 
....................    output_c(0b00000000); 
*
0966:  CLRF   07
....................    //output_e(0b00000000); 
.................... } 
0967:  BSF    0A.3
0968:  BCF    0A.4
0969:  GOTO   410 (RETURN)
....................  
....................  

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT NODEBUG NOPROTECT BROWNOUT NOLVP NOCPD NOWRT
